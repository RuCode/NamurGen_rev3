   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	setRelayState.part.2:
  12               	.LFB53:
  13               		.file 1 "Relay.h"
   1:Relay.h       **** /*
   2:Relay.h       ****  * Relay.h
   3:Relay.h       ****  *
   4:Relay.h       ****  *  Created on: 04.10.2015
   5:Relay.h       ****  *      Author: anton
   6:Relay.h       ****  */
   7:Relay.h       **** 
   8:Relay.h       **** #ifndef RELAY_H_
   9:Relay.h       **** #define RELAY_H_
  10:Relay.h       **** 
  11:Relay.h       **** #ifndef F_CPU
  12:Relay.h       **** #define F_CPU 8000000UL
  13:Relay.h       **** #endif
  14:Relay.h       **** 
  15:Relay.h       **** #include <avr/io.h>
  16:Relay.h       **** #include <util/delay.h>
  17:Relay.h       **** #include "sysfunc.h"
  18:Relay.h       **** 
  19:Relay.h       **** #define RELAY_BOTTOM 2
  20:Relay.h       **** #define RELAY_MIDDLE 1
  21:Relay.h       **** #define RELAY_TOP 0
  22:Relay.h       **** 
  23:Relay.h       **** void setRelayState(int RelayNum, boolean isOpen) {
  14               		.loc 1 23 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  20               	.LVL0:
  24:Relay.h       **** 
  25:Relay.h       ****     if (RelayNum == RELAY_BOTTOM)
  26:Relay.h       ****     {
  27:Relay.h       ****         // –ù–µ –±–æ–ª—å—à–æ–π —Ö–∞–∫, —Ç–∞–∫ –∫–∞–∫ –Ω–∏–∂–Ω–µ–µ —Ä–µ–ª–µ —Ç–µ–ø–µ—Ä—å —É –Ω–∞—Å P
  28:Relay.h       ****         if (isOpen) {
  29:Relay.h       ****             PORTC |= (1 << 5);
  21               		.loc 1 29 0
  22 0000 AD9A      		sbi 0x15,5
  23 0002 0895      		ret
  24               		.cfi_endproc
  25               	.LFE53:
  27               	.global	usbFunctionRead
  29               	usbFunctionRead:
  30               	.LFB7:
  31               		.file 2 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * main.c
   3:main.c        ****  *
   4:main.c        ****  *  Created on: 25.09.2015
   5:main.c        ****  *      Author: anton
   6:main.c        ****  *
   7:main.c        ****  ************************************************************************
   8:main.c        ****  * –í—Å—ë –ø—É—Ç–∞—é—Å—å —Å –±–∏—Ç–æ–≤—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏.
   9:main.c        ****  *
  10:main.c        ****  * –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å 7-–π –±–∏—Ç –≤ –±–∞–π—Ç–µ (–≤—Å–µ–≥–æ –±–∏—Ç–æ–≤ –æ—Ç 0 –¥–æ 7)
  11:main.c        ****  *
  12:main.c        ****  * SREG |= (1<<7);
  13:main.c        ****  *
  14:main.c        ****  * –°–±—Ä–æ—Å–∏—Ç—å 7-–π –±–∏—Ç –≤ –±–∞–π—Ç–µ:
  15:main.c        ****  *
  16:main.c        ****  * SREG &= ~ (1<<7);
  17:main.c        ****  *
  18:main.c        ****  * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ª–∏ 7-–π –±–∏—Ç –≤ –±–∞–π—Ç–µ:
  19:main.c        ****  *
  20:main.c        ****  * if (SREG & 1 << 7)
  21:main.c        ****  *
  22:main.c        ****  * –∏–ª–∏ –º–∞–∫—Ä–æ—Å bit_test
  23:main.c        ****  *
  24:main.c        ****  ************************************************************************
  25:main.c        ****  * –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∂–µ–ª–µ–∑–∞ - –ø–æ—Ä—Ç—ã –º–µ–≥–∏8
  26:main.c        ****  ************************************************************************
  27:main.c        ****  *
  28:main.c        ****  *						   ________
  29:main.c        ****  *			RESET - PC6 --|1*   28 |-- PC5 - –†–µ–ª–µ 3
  30:main.c        ****  *		    –†–µ–ª–µ1 - PD0 --|2	27 |-- PC4 - –°–≤–æ–±–æ–¥–Ω–æ
  31:main.c        ****  *		    –†–µ–ª–µ2 - PD1	--|3	26 |-- PC3 - –ö–Ω–æ–ø–∫–∞ –≤–Ω–∏–∑
  32:main.c        ****  * –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ D+ - PD2	--|4	25 |-- PC2 - –ö–Ω–æ–ø–∫–∞ –≤–ø—Ä–∞–≤–æ
  33:main.c        ****  *		       D- - PD3	--|5	24 |-- PC1 - –ö–Ω–æ–ø–∫–∞ –≤—ã–±–æ—Ä
  34:main.c        ****  *		  LCD DB4 - PD4	--|6	23 |-- PC0 - –ö–Ω–æ–ø–∫–∞ –≤–ª–µ–≤–æ
  35:main.c        ****  *		  –ü–∏—Ç–∞–Ω–∏–µ - VCC	--|7	22 |-- AGND - –°–æ–µ–¥–∏–Ω—ë–Ω —Å GND
  36:main.c        ****  *			–ó–µ–º–ª—è - GND	--|8	21 |-- AREF - –í–∏—Å–∏—Ç –≤ –≤–æ–∑–¥—É—Ö–µ
  37:main.c        ****  *			–ö–≤–∞—Ä—Ü - PB6	--|9	20 |-- AVCC - –°–æ–µ–¥–∏–Ω—ë–Ω —Å VCC
  38:main.c        ****  *			–ö–≤–∞—Ä—Ü - PB7	--|10	19 |-- PB5 - SCK
  39:main.c        ****  *		  LCD DB5 - PD5	--|11	18 |-- PB4 - MISO
  40:main.c        ****  *		  LCD DB6 - PD6	--|12	17 |-- PB3 - MOSI
  41:main.c        ****  *		  LCD DB7 - PD7	--|13	16 |-- PB2 - –ö–Ω–æ–ø–∫–∞ –≤–≤–µ—Ä—Ö
  42:main.c        ****  *		    LCD E - PB0	--|14	15 |-- PB1 - LCD A0
  43:main.c        ****  *						  |--------|
  44:main.c        ****  *
  45:main.c        ****  ************************************************************************/
  46:main.c        **** 
  47:main.c        **** #define F_CPU 16000000UL
  48:main.c        **** 
  49:main.c        **** #include <avr/io.h>
  50:main.c        **** #include <util/delay.h>
  51:main.c        **** #include <math.h>
  52:main.c        **** #include <avr/interrupt.h>
  53:main.c        **** #include <avr/pgmspace.h>   /* –Ω—É–∂–Ω–æ –¥–ª—è usbdrv.h */
  54:main.c        **** #include "usbdrv.h"
  55:main.c        **** 
  56:main.c        **** struct dataexchange_t       // –û–ø–∏—Å–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω
  57:main.c        **** {
  58:main.c        ****    uchar b1;        // –Ø —Ä–µ—à–∏–ª –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ –Ω–∞–ø–∏—Å–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –Ω–∞
  59:main.c        ****    uchar b2;        // –ù–∞ –∫–∞–∂–¥—ã–π –±–∞–π—Ç –ø–æ–¥—Ü–µ–ø–∏–º –Ω–æ–≥—É –∏–∑ PORTB. –ö–æ–Ω–µ—á–
  60:main.c        ****    uchar b3;        // –Ω–µ —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ (–≤—Å–µ–≥–æ —Ç–æ 3 –±–∏—Ç–∞ –Ω—É–∂–Ω–æ).
  61:main.c        **** };                  // –ù–æ –≤ —Ü–µ–ª—è—Ö –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤ —Å–∞–º—ã–π —Ä–∞–∑.
  62:main.c        ****                     // –î–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏ –ø—Ä–∏–∫—Ä—É—Ç–∏—Ç—å –ø–æ —Å–≤–µ—Ç–æ–¥–∏–æ–¥—É
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** struct dataexchange_t pdata = {0, 0, 0};
  66:main.c        **** 
  67:main.c        **** 
  68:main.c        **** /*PROGMEM*/ char usbHidReportDescriptor[22] = { // USB report descriptor         // –î–µ—Å–∫—Ä–∏–ø—
  69:main.c        ****     0x06, 0x00, 0xff,                       // USAGE_PAGE (Generic Desktop)
  70:main.c        ****     0x09, 0x01,                             // USAGE (Vendor Usage 1)
  71:main.c        ****     0xa1, 0x01,                             // COLLECTION (Application)
  72:main.c        ****     0x15, 0x00,                             //    LOGICAL_MINIMUM (0)        // min. –∑–Ω–∞—á–µ–Ω–∏
  73:main.c        ****     0x26, 0xff, 0x00,                       //    LOGICAL_MAXIMUM (255)      // max. –∑–Ω–∞—á–µ–Ω–∏
  74:main.c        ****     0x75, 0x08,                             //    REPORT_SIZE (8)            // –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—
  75:main.c        ****     0x95, sizeof(struct dataexchange_t),    //    REPORT_COUNT               // –∫–æ–ª–∏—á–µ—Å—Ç–≤–
  76:main.c        ****     0x09, 0x00,                             //    USAGE (Undefined)
  77:main.c        ****     0xb2, 0x02, 0x01,                       //    FEATURE (Data,Var,Abs,Buf)
  78:main.c        ****     0xc0                                    // END_COLLECTION
  79:main.c        **** };
  80:main.c        **** /* –ó–¥–µ—Å—å –º—ã –æ–ø–∏—Å–∞–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω report, –∏–∑-–∑–∞ —á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ 
  81:main.c        ****  * –° –µ–≥–æ –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–¥–∞–¥–∏–º 3 –±–∞–π—Ç–∞ –¥–∞–Ω–Ω—ã—Ö (—Ä–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ
  82:main.c        ****  */
  83:main.c        **** 
  84:main.c        **** 
  85:main.c        **** /* –≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç —Å—Ç–∞—Ç—É—Å —Ç–µ–∫—É—â–µ–π –ø–µ—Ä–µ–¥–∞—á–∏ */
  86:main.c        **** static uchar    currentAddress;
  87:main.c        **** static uchar    bytesRemaining;
  88:main.c        **** 
  89:main.c        **** 
  90:main.c        **** /* usbFunctionRead() –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–æ–≥–¥–∞ —Ö–æ—Å—Ç –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ—Ä—Ü–∏—é –
  91:main.c        ****  * –î–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å–º. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –≤ usbdr
  92:main.c        ****  */
  93:main.c        **** uchar   usbFunctionRead(uchar *data, uchar len)
  94:main.c        **** {
  32               		.loc 2 94 0
  33               		.cfi_startproc
  34               	.LVL1:
  35 0004 CF93      		push r28
  36               	.LCFI0:
  37               		.cfi_def_cfa_offset 3
  38               		.cfi_offset 28, -2
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 1 */
  42               	.L__stack_usage = 1
  95:main.c        ****     if(len > bytesRemaining)
  43               		.loc 2 95 0
  44 0006 7091 0000 		lds r23,bytesRemaining
  45 000a 7617      		cp r23,r22
  46 000c 00F4      		brsh .L3
  47 000e 672F      		mov r22,r23
  48               	.LVL2:
  49               	.L3:
  96:main.c        ****         len = bytesRemaining;
  97:main.c        **** 
  98:main.c        ****     uchar *buffer = (uchar*)&pdata;
  99:main.c        **** 
 100:main.c        ****     if(!currentAddress)        // –ù–∏ –æ–¥–∏–Ω –∫—É—Å–æ–∫ –¥–∞–Ω–Ω—ã—Ö –µ—â–µ –Ω–µ –ø—Ä–æ—á–∏—Ç–∞–
  50               		.loc 2 100 0
  51 0010 C091 0000 		lds r28,currentAddress
  52 0014 C111      		cpse r28,__zero_reg__
  53 0016 00C0      		rjmp .L4
 101:main.c        ****     {                          // –ó–∞–ø–æ–ª–Ω–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏
 102:main.c        ****         if ( PINB & _BV(1) )
  54               		.loc 2 102 0
  55 0018 B19B      		sbis 0x16,1
  56 001a 00C0      		rjmp .L5
 103:main.c        ****             pdata.b1 = 1;
  57               		.loc 2 103 0
  58 001c 21E0      		ldi r18,lo8(1)
  59 001e 2093 0000 		sts pdata,r18
  60 0022 00C0      		rjmp .L6
  61               	.L5:
 104:main.c        ****         else
 105:main.c        ****             pdata.b1 = 0;
  62               		.loc 2 105 0
  63 0024 1092 0000 		sts pdata,__zero_reg__
  64               	.L6:
 106:main.c        **** 
 107:main.c        **** 
 108:main.c        ****         if ( PINB & _BV(2) )
  65               		.loc 2 108 0
  66 0028 B29B      		sbis 0x16,2
  67 002a 00C0      		rjmp .L7
 109:main.c        ****             pdata.b2 = 1;
  68               		.loc 2 109 0
  69 002c 21E0      		ldi r18,lo8(1)
  70 002e 2093 0000 		sts pdata+1,r18
  71 0032 00C0      		rjmp .L8
  72               	.L7:
 110:main.c        ****         else
 111:main.c        ****             pdata.b2 = 0;
  73               		.loc 2 111 0
  74 0034 1092 0000 		sts pdata+1,__zero_reg__
  75               	.L8:
 112:main.c        **** 
 113:main.c        **** 
 114:main.c        ****         if ( PINB & _BV(3) )
  76               		.loc 2 114 0
  77 0038 B39B      		sbis 0x16,3
  78 003a 00C0      		rjmp .L9
 115:main.c        ****             pdata.b3 = 1;
  79               		.loc 2 115 0
  80 003c 21E0      		ldi r18,lo8(1)
  81 003e 2093 0000 		sts pdata+2,r18
  82               	.L4:
  83 0042 FC01      		movw r30,r24
  94:main.c        ****     if(len > bytesRemaining)
  84               		.loc 2 94 0 discriminator 1
  85 0044 20E0      		ldi r18,0
  86 0046 30E0      		ldi r19,0
  87 0048 4C2F      		mov r20,r28
  88 004a 50E0      		ldi r21,0
  89 004c 4050      		subi r20,lo8(-(pdata))
  90 004e 5040      		sbci r21,hi8(-(pdata))
  91 0050 00C0      		rjmp .L10
  92               	.L9:
 116:main.c        ****         else
 117:main.c        ****             pdata.b3 = 0;
  93               		.loc 2 117 0
  94 0052 1092 0000 		sts pdata+2,__zero_reg__
  95 0056 00C0      		rjmp .L4
  96               	.LVL3:
  97               	.L10:
 118:main.c        ****     }
 119:main.c        **** 
 120:main.c        ****     uchar j;
 121:main.c        ****     for(j=0; j<len; j++)
  98               		.loc 2 121 0 discriminator 1
  99 0058 2617      		cp r18,r22
 100 005a 00F4      		brsh .L13
 101 005c DA01      		movw r26,r20
 102 005e A20F      		add r26,r18
 103 0060 B31F      		adc r27,r19
 122:main.c        ****         data[j] = buffer[j+currentAddress];
 104               		.loc 2 122 0 discriminator 2
 105 0062 8C91      		ld r24,X
 106 0064 8193      		st Z+,r24
 107               	.LVL4:
 108 0066 2F5F      		subi r18,-1
 109 0068 3F4F      		sbci r19,-1
 110               	.LVL5:
 111 006a 00C0      		rjmp .L10
 112               	.L13:
 123:main.c        **** 
 124:main.c        ****     currentAddress += len;
 113               		.loc 2 124 0
 114 006c C60F      		add r28,r22
 115 006e C093 0000 		sts currentAddress,r28
 125:main.c        ****     bytesRemaining -= len;
 116               		.loc 2 125 0
 117 0072 761B      		sub r23,r22
 118 0074 7093 0000 		sts bytesRemaining,r23
 126:main.c        ****     return len;
 127:main.c        **** }
 119               		.loc 2 127 0
 120 0078 862F      		mov r24,r22
 121               	/* epilogue start */
 122 007a CF91      		pop r28
 123 007c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE7:
 127               	.global	usbFunctionWrite
 129               	usbFunctionWrite:
 130               	.LFB8:
 128:main.c        **** 
 129:main.c        **** 
 130:main.c        **** /* usbFunctionWrite() –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–æ–≥–¥–∞ —Ö–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ—Ä—Ü–∏—é –¥
 131:main.c        ****  * –î–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å–º. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –≤ usbdr
 132:main.c        ****  */
 133:main.c        **** uchar   usbFunctionWrite(uchar *data, uchar len)
 134:main.c        **** {
 131               		.loc 2 134 0
 132               		.cfi_startproc
 133               	.LVL6:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 135:main.c        ****     if(bytesRemaining == 0)
 138               		.loc 2 135 0
 139 007e 4091 0000 		lds r20,bytesRemaining
 140 0082 4423      		tst r20
 141 0084 01F0      		breq .L26
 142 0086 4617      		cp r20,r22
 143 0088 00F4      		brsh .L16
 144 008a 642F      		mov r22,r20
 145               	.LVL7:
 146               	.L16:
 136:main.c        ****         return 1;               /* –∫–æ–Ω–µ—Ü –ø–µ—Ä–µ–¥–∞—á–∏ */
 137:main.c        **** 
 138:main.c        ****     if(len > bytesRemaining)
 139:main.c        ****         len = bytesRemaining;
 140:main.c        **** 
 141:main.c        ****     uchar *buffer = (uchar*)&pdata;
 142:main.c        **** 
 143:main.c        ****     uchar j;
 144:main.c        ****     for(j=0; j<len; j++)
 145:main.c        ****         buffer[j+currentAddress] = data[j];
 147               		.loc 2 145 0
 148 008c 5091 0000 		lds r21,currentAddress
 149 0090 FC01      		movw r30,r24
 144:main.c        ****         buffer[j+currentAddress] = data[j];
 150               		.loc 2 144 0
 151 0092 80E0      		ldi r24,0
 152 0094 90E0      		ldi r25,0
 153               	.LVL8:
 154 0096 252F      		mov r18,r21
 155 0098 30E0      		ldi r19,0
 156 009a 2050      		subi r18,lo8(-(pdata))
 157 009c 3040      		sbci r19,hi8(-(pdata))
 158               	.LVL9:
 159               	.L17:
 144:main.c        ****         buffer[j+currentAddress] = data[j];
 160               		.loc 2 144 0 is_stmt 0 discriminator 1
 161 009e 8617      		cp r24,r22
 162 00a0 00F4      		brsh .L30
 163               		.loc 2 145 0 is_stmt 1 discriminator 2
 164 00a2 7191      		ld r23,Z+
 165 00a4 D901      		movw r26,r18
 166 00a6 A80F      		add r26,r24
 167 00a8 B91F      		adc r27,r25
 168 00aa 7C93      		st X,r23
 169               	.LVL10:
 170 00ac 0196      		adiw r24,1
 171               	.LVL11:
 172 00ae 00C0      		rjmp .L17
 173               	.L30:
 146:main.c        **** 
 147:main.c        ****     currentAddress += len;
 174               		.loc 2 147 0
 175 00b0 560F      		add r21,r22
 176 00b2 5093 0000 		sts currentAddress,r21
 148:main.c        ****     bytesRemaining -= len;
 177               		.loc 2 148 0
 178 00b6 461B      		sub r20,r22
 179 00b8 4093 0000 		sts bytesRemaining,r20
 149:main.c        **** 
 150:main.c        ****     if(bytesRemaining == 0)     // –í—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã
 180               		.loc 2 150 0
 181 00bc 4111      		cpse r20,__zero_reg__
 182 00be 00C0      		rjmp .L19
 151:main.c        ****     {                           // –í—ã—Å—Ç–∞–≤–∏–º –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ PORTB
 152:main.c        ****         if ( pdata.b1 )
 183               		.loc 2 152 0
 184 00c0 8091 0000 		lds r24,pdata
 185               	.LVL12:
 186 00c4 8823      		tst r24
 187 00c6 01F0      		breq .L20
 153:main.c        ****             PORTB |= _BV(1);
 188               		.loc 2 153 0
 189 00c8 C19A      		sbi 0x18,1
 190 00ca 00C0      		rjmp .L21
 191               	.L20:
 154:main.c        ****         else
 155:main.c        ****             PORTB &= ~_BV(1);
 192               		.loc 2 155 0
 193 00cc C198      		cbi 0x18,1
 194               	.L21:
 156:main.c        **** 
 157:main.c        **** 
 158:main.c        ****         if ( pdata.b2 )
 195               		.loc 2 158 0
 196 00ce 8091 0000 		lds r24,pdata+1
 197 00d2 8823      		tst r24
 198 00d4 01F0      		breq .L22
 159:main.c        ****             PORTB |= _BV(2);
 199               		.loc 2 159 0
 200 00d6 C29A      		sbi 0x18,2
 201 00d8 00C0      		rjmp .L23
 202               	.L22:
 160:main.c        ****         else
 161:main.c        ****             PORTB &= ~_BV(2);
 203               		.loc 2 161 0
 204 00da C298      		cbi 0x18,2
 205               	.L23:
 162:main.c        **** 
 163:main.c        **** 
 164:main.c        ****         if ( pdata.b3 )
 206               		.loc 2 164 0
 207 00dc 8091 0000 		lds r24,pdata+2
 208 00e0 8823      		tst r24
 209 00e2 01F0      		breq .L24
 165:main.c        ****             PORTB |= _BV(3);
 210               		.loc 2 165 0
 211 00e4 C39A      		sbi 0x18,3
 212 00e6 00C0      		rjmp .L19
 213               	.L24:
 166:main.c        ****         else
 167:main.c        ****             PORTB &= ~_BV(3);
 214               		.loc 2 167 0
 215 00e8 C398      		cbi 0x18,3
 216               	.L19:
 168:main.c        ****     }
 169:main.c        **** 
 170:main.c        ****     return bytesRemaining == 0; /* 0 –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –µ—Å—Ç—å –µ—â–µ –¥–∞–Ω–Ω—ã–µ */
 217               		.loc 2 170 0
 218 00ea 81E0      		ldi r24,lo8(1)
 219 00ec 9091 0000 		lds r25,bytesRemaining
 220 00f0 9923      		tst r25
 221 00f2 01F0      		breq .L15
 222 00f4 80E0      		ldi r24,0
 223 00f6 0895      		ret
 224               	.LVL13:
 225               	.L26:
 136:main.c        **** 
 226               		.loc 2 136 0
 227 00f8 81E0      		ldi r24,lo8(1)
 228               	.LVL14:
 229               	.L15:
 171:main.c        **** }
 230               		.loc 2 171 0
 231 00fa 0895      		ret
 232               		.cfi_endproc
 233               	.LFE8:
 235               	.global	usbFunctionSetup
 237               	usbFunctionSetup:
 238               	.LFB9:
 172:main.c        **** 
 173:main.c        **** /* ------------------------------------------------------------------------- */
 174:main.c        **** 
 175:main.c        **** usbMsgLen_t usbFunctionSetup(uchar data[8])
 176:main.c        **** {
 239               		.loc 2 176 0
 240               		.cfi_startproc
 241               	.LVL15:
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
 177:main.c        **** usbRequest_t    *rq = (void *)data;
 178:main.c        **** 
 179:main.c        ****     if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ *
 246               		.loc 2 179 0
 247 00fc FC01      		movw r30,r24
 248 00fe 2081      		ld r18,Z
 249 0100 2076      		andi r18,lo8(96)
 250 0102 2032      		cpi r18,lo8(32)
 251 0104 01F4      		brne .L34
 180:main.c        ****         if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowb
 252               		.loc 2 180 0
 253 0106 8181      		ldd r24,Z+1
 254               	.LVL16:
 255 0108 877F      		andi r24,lo8(-9)
 256 010a 8130      		cpi r24,lo8(1)
 257 010c 01F4      		brne .L34
 181:main.c        ****             // —É –Ω–∞—Å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ —Ä–∞–∑–Ω–æ–≤–∏–¥–Ω–æ—Å—Ç—å —Ä–µ–ø–æ—Ä—Ç–∞, –º–æ–∂–µ–
 182:main.c        ****             bytesRemaining = sizeof(struct dataexchange_t);
 258               		.loc 2 182 0
 259 010e 83E0      		ldi r24,lo8(3)
 260 0110 8093 0000 		sts bytesRemaining,r24
 183:main.c        ****             currentAddress = 0;
 261               		.loc 2 183 0
 262 0114 1092 0000 		sts currentAddress,__zero_reg__
 184:main.c        ****             return USB_NO_MSG;  // –∏—Å–ø–æ–ª—å–∑—É–µ–º usbFunctionRead() –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –
 263               		.loc 2 184 0
 264 0118 8FEF      		ldi r24,lo8(-1)
 265 011a 0895      		ret
 266               	.L34:
 185:main.c        ****         }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
 186:main.c        ****             // —É –Ω–∞—Å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ —Ä–∞–∑–Ω–æ–≤–∏–¥–Ω–æ—Å—Ç—å —Ä–µ–ø–æ—Ä—Ç–∞, –º–æ–∂–µ–
 187:main.c        ****             bytesRemaining = sizeof(struct dataexchange_t);
 188:main.c        ****             currentAddress = 0;
 189:main.c        ****             return USB_NO_MSG;  // –∏—Å–ø–æ–ª—å–∑—É–µ–º usbFunctionWrite() –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—
 190:main.c        ****         }
 191:main.c        ****     }else{
 192:main.c        ****         /* –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –º—ã –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º */
 193:main.c        ****     }
 194:main.c        ****     return 0;
 267               		.loc 2 194 0
 268 011c 80E0      		ldi r24,0
 195:main.c        **** }
 269               		.loc 2 195 0
 270 011e 0895      		ret
 271               		.cfi_endproc
 272               	.LFE9:
 274               	.global	readPulseDuration
 276               	readPulseDuration:
 277               	.LFB10:
 278               		.file 3 "EEPROM_mem.h"
   1:EEPROM_mem.h  **** /*
   2:EEPROM_mem.h  ****  * EEPROM_mem.h
   3:EEPROM_mem.h  ****  *
   4:EEPROM_mem.h  ****  *  Created on: 16.10.2015
   5:EEPROM_mem.h  ****  *      Author: anton
   6:EEPROM_mem.h  ****  */
   7:EEPROM_mem.h  **** 
   8:EEPROM_mem.h  **** #ifndef EEPROM_MEM_H_
   9:EEPROM_mem.h  **** #define EEPROM_MEM_H_
  10:EEPROM_mem.h  **** 
  11:EEPROM_mem.h  **** #include <avr/eeprom.h>
  12:EEPROM_mem.h  **** 
  13:EEPROM_mem.h  **** // 16-–º–∏ —Ä–∞–∑—Ä—è–¥–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤ EEPROM
  14:EEPROM_mem.h  **** uint16_t eeprom_pulse_duration EEMEM = 2000;
  15:EEPROM_mem.h  **** uint16_t eeprom_pause_duration EEMEM = 1000;
  16:EEPROM_mem.h  **** uint16_t eeprom_impulse_count EEMEM = 1000;
  17:EEPROM_mem.h  **** uint16_t eeprom_mode EEMEM = 0;
  18:EEPROM_mem.h  **** 
  19:EEPROM_mem.h  **** int readPulseDuration() {
 279               		.loc 3 19 0
 280               		.cfi_startproc
 281               	/* prologue: function */
 282               	/* frame size = 0 */
 283               	/* stack size = 0 */
 284               	.L__stack_usage = 0
  20:EEPROM_mem.h  **** 	return (int) eeprom_read_word(&eeprom_pulse_duration);
 285               		.loc 3 20 0
 286 0120 80E0      		ldi r24,lo8(eeprom_pulse_duration)
 287 0122 90E0      		ldi r25,hi8(eeprom_pulse_duration)
 288 0124 00C0      		rjmp __eerd_word_m8
 289               	.LVL17:
 290               		.cfi_endproc
 291               	.LFE10:
 293               	.global	writePulseDuration
 295               	writePulseDuration:
 296               	.LFB11:
  21:EEPROM_mem.h  **** }
  22:EEPROM_mem.h  **** 
  23:EEPROM_mem.h  **** void writePulseDuration(int val) {
 297               		.loc 3 23 0
 298               		.cfi_startproc
 299               	.LVL18:
 300               	/* prologue: function */
 301               	/* frame size = 0 */
 302               	/* stack size = 0 */
 303               	.L__stack_usage = 0
  24:EEPROM_mem.h  **** 	eeprom_write_word(&eeprom_pulse_duration, val);
 304               		.loc 3 24 0
 305 0126 BC01      		movw r22,r24
 306 0128 80E0      		ldi r24,lo8(eeprom_pulse_duration)
 307 012a 90E0      		ldi r25,hi8(eeprom_pulse_duration)
 308               	.LVL19:
 309 012c 00C0      		rjmp __eewr_word_m8
 310               	.LVL20:
 311               		.cfi_endproc
 312               	.LFE11:
 314               	.global	readPauseDuration
 316               	readPauseDuration:
 317               	.LFB12:
  25:EEPROM_mem.h  **** }
  26:EEPROM_mem.h  **** 
  27:EEPROM_mem.h  **** int readPauseDuration() {
 318               		.loc 3 27 0
 319               		.cfi_startproc
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 0 */
 323               	.L__stack_usage = 0
  28:EEPROM_mem.h  **** 	return (int) eeprom_read_word(&eeprom_pause_duration);
 324               		.loc 3 28 0
 325 012e 80E0      		ldi r24,lo8(eeprom_pause_duration)
 326 0130 90E0      		ldi r25,hi8(eeprom_pause_duration)
 327 0132 00C0      		rjmp __eerd_word_m8
 328               	.LVL21:
 329               		.cfi_endproc
 330               	.LFE12:
 332               	.global	writePauseDuration
 334               	writePauseDuration:
 335               	.LFB13:
  29:EEPROM_mem.h  **** }
  30:EEPROM_mem.h  **** 
  31:EEPROM_mem.h  **** void writePauseDuration(int val) {
 336               		.loc 3 31 0
 337               		.cfi_startproc
 338               	.LVL22:
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
  32:EEPROM_mem.h  **** 	eeprom_write_word(&eeprom_pause_duration, val);
 343               		.loc 3 32 0
 344 0134 BC01      		movw r22,r24
 345 0136 80E0      		ldi r24,lo8(eeprom_pause_duration)
 346 0138 90E0      		ldi r25,hi8(eeprom_pause_duration)
 347               	.LVL23:
 348 013a 00C0      		rjmp __eewr_word_m8
 349               	.LVL24:
 350               		.cfi_endproc
 351               	.LFE13:
 353               	.global	readImpulseCount
 355               	readImpulseCount:
 356               	.LFB14:
  33:EEPROM_mem.h  **** }
  34:EEPROM_mem.h  **** 
  35:EEPROM_mem.h  **** int readImpulseCount() {
 357               		.loc 3 35 0
 358               		.cfi_startproc
 359               	/* prologue: function */
 360               	/* frame size = 0 */
 361               	/* stack size = 0 */
 362               	.L__stack_usage = 0
  36:EEPROM_mem.h  **** 	return (int) eeprom_read_word(&eeprom_impulse_count);
 363               		.loc 3 36 0
 364 013c 80E0      		ldi r24,lo8(eeprom_impulse_count)
 365 013e 90E0      		ldi r25,hi8(eeprom_impulse_count)
 366 0140 00C0      		rjmp __eerd_word_m8
 367               	.LVL25:
 368               		.cfi_endproc
 369               	.LFE14:
 371               	.global	writeImpulseCount
 373               	writeImpulseCount:
 374               	.LFB15:
  37:EEPROM_mem.h  **** }
  38:EEPROM_mem.h  **** 
  39:EEPROM_mem.h  **** void writeImpulseCount(int val) {
 375               		.loc 3 39 0
 376               		.cfi_startproc
 377               	.LVL26:
 378               	/* prologue: function */
 379               	/* frame size = 0 */
 380               	/* stack size = 0 */
 381               	.L__stack_usage = 0
  40:EEPROM_mem.h  **** 	eeprom_write_word(&eeprom_impulse_count, val);
 382               		.loc 3 40 0
 383 0142 BC01      		movw r22,r24
 384 0144 80E0      		ldi r24,lo8(eeprom_impulse_count)
 385 0146 90E0      		ldi r25,hi8(eeprom_impulse_count)
 386               	.LVL27:
 387 0148 00C0      		rjmp __eewr_word_m8
 388               	.LVL28:
 389               		.cfi_endproc
 390               	.LFE15:
 392               	.global	readMode
 394               	readMode:
 395               	.LFB16:
  41:EEPROM_mem.h  **** }
  42:EEPROM_mem.h  **** 
  43:EEPROM_mem.h  **** int readMode() {
 396               		.loc 3 43 0
 397               		.cfi_startproc
 398               	/* prologue: function */
 399               	/* frame size = 0 */
 400               	/* stack size = 0 */
 401               	.L__stack_usage = 0
  44:EEPROM_mem.h  **** 	return (int) eeprom_read_word(&eeprom_mode);
 402               		.loc 3 44 0
 403 014a 80E0      		ldi r24,lo8(eeprom_mode)
 404 014c 90E0      		ldi r25,hi8(eeprom_mode)
 405 014e 00C0      		rjmp __eerd_word_m8
 406               	.LVL29:
 407               		.cfi_endproc
 408               	.LFE16:
 410               	.global	writeMode
 412               	writeMode:
 413               	.LFB17:
  45:EEPROM_mem.h  **** }
  46:EEPROM_mem.h  **** 
  47:EEPROM_mem.h  **** void writeMode(int val) {
 414               		.loc 3 47 0
 415               		.cfi_startproc
 416               	.LVL30:
 417               	/* prologue: function */
 418               	/* frame size = 0 */
 419               	/* stack size = 0 */
 420               	.L__stack_usage = 0
  48:EEPROM_mem.h  **** 	eeprom_write_word(&eeprom_mode, val);
 421               		.loc 3 48 0
 422 0150 BC01      		movw r22,r24
 423 0152 80E0      		ldi r24,lo8(eeprom_mode)
 424 0154 90E0      		ldi r25,hi8(eeprom_mode)
 425               	.LVL31:
 426 0156 00C0      		rjmp __eewr_word_m8
 427               	.LVL32:
 428               		.cfi_endproc
 429               	.LFE17:
 431               	.global	__floatsisf
 432               	.global	__divsf3
 433               	.global	__fixsfsi
 434               	.global	power
 436               	power:
 437               	.LFB18:
 438               		.file 4 "sysfunc.h"
   1:sysfunc.h     **** /*
   2:sysfunc.h     ****  * sysfunc.h
   3:sysfunc.h     ****  *
   4:sysfunc.h     ****  *  Created on: 06.10.2015
   5:sysfunc.h     ****  *      Author: anton
   6:sysfunc.h     ****  */
   7:sysfunc.h     **** 
   8:sysfunc.h     **** #ifndef SYSFUNC_H_
   9:sysfunc.h     **** #define SYSFUNC_H_
  10:sysfunc.h     **** 
  11:sysfunc.h     **** #define boolean char
  12:sysfunc.h     **** #define false 0
  13:sysfunc.h     **** #define true 1
  14:sysfunc.h     **** 
  15:sysfunc.h     **** // –í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å
  16:sysfunc.h     **** int power(int x, int n) {
 439               		.loc 4 16 0
 440               		.cfi_startproc
 441               	.LVL33:
 442 0158 0F93      		push r16
 443               	.LCFI1:
 444               		.cfi_def_cfa_offset 3
 445               		.cfi_offset 16, -2
 446 015a 1F93      		push r17
 447               	.LCFI2:
 448               		.cfi_def_cfa_offset 4
 449               		.cfi_offset 17, -3
 450 015c CF93      		push r28
 451               	.LCFI3:
 452               		.cfi_def_cfa_offset 5
 453               		.cfi_offset 28, -4
 454 015e DF93      		push r29
 455               	.LCFI4:
 456               		.cfi_def_cfa_offset 6
 457               		.cfi_offset 29, -5
 458               	/* prologue: function */
 459               	/* frame size = 0 */
 460               	/* stack size = 4 */
 461               	.L__stack_usage = 4
 462 0160 EB01      		movw r28,r22
 463               		.loc 4 16 0
 464 0162 01E0      		ldi r16,lo8(1)
 465 0164 10E0      		ldi r17,0
 466               	.LVL34:
 467               	.L44:
  17:sysfunc.h     **** 	if (n == 0)
 468               		.loc 4 17 0
 469 0166 2097      		sbiw r28,0
 470 0168 01F0      		breq .L45
  18:sysfunc.h     **** 		return 1;
  19:sysfunc.h     **** 	if (n < 0)
 471               		.loc 4 19 0
 472 016a D7FF      		sbrs r29,7
 473 016c 00C0      		rjmp .L46
  20:sysfunc.h     **** 		return power(1.0 / x, -n);
 474               		.loc 4 20 0
 475 016e D195      		neg r29
 476 0170 C195      		neg r28
 477 0172 D109      		sbc r29,__zero_reg__
 478 0174 BC01      		movw r22,r24
 479 0176 8827      		clr r24
 480 0178 77FD      		sbrc r23,7
 481 017a 8095      		com r24
 482 017c 982F      		mov r25,r24
 483 017e 00D0      		rcall __floatsisf
 484               	.LVL35:
 485 0180 9B01      		movw r18,r22
 486 0182 AC01      		movw r20,r24
 487 0184 60E0      		ldi r22,0
 488 0186 70E0      		ldi r23,0
 489 0188 80E8      		ldi r24,lo8(-128)
 490 018a 9FE3      		ldi r25,lo8(63)
 491 018c 00D0      		rcall __divsf3
 492               	.LVL36:
 493 018e 00D0      		rcall __fixsfsi
 494               	.LVL37:
 495 0190 CB01      		movw r24,r22
 496 0192 00C0      		rjmp .L44
 497               	.L46:
  21:sysfunc.h     **** 	return x * power(x, n - 1);
 498               		.loc 4 21 0
 499 0194 2197      		sbiw r28,1
 500 0196 9801      		movw r18,r16
 501 0198 289F      		mul r18,r24
 502 019a 8001      		movw r16,r0
 503 019c 299F      		mul r18,r25
 504 019e 100D      		add r17,r0
 505 01a0 389F      		mul r19,r24
 506 01a2 100D      		add r17,r0
 507 01a4 1124      		clr r1
 508 01a6 00C0      		rjmp .L44
 509               	.L45:
  22:sysfunc.h     **** }
 510               		.loc 4 22 0
 511 01a8 C801      		movw r24,r16
 512               	/* epilogue start */
 513 01aa DF91      		pop r29
 514 01ac CF91      		pop r28
 515 01ae 1F91      		pop r17
 516 01b0 0F91      		pop r16
 517 01b2 0895      		ret
 518               		.cfi_endproc
 519               	.LFE18:
 521               	.global	strlen
 523               	strlen:
 524               	.LFB19:
  23:sysfunc.h     **** 
  24:sysfunc.h     **** // –î–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏
  25:sysfunc.h     **** int strlen(char buff[]) {
 525               		.loc 4 25 0
 526               		.cfi_startproc
 527               	.LVL38:
 528               	/* prologue: function */
 529               	/* frame size = 0 */
 530               	/* stack size = 0 */
 531               	.L__stack_usage = 0
  26:sysfunc.h     **** 	int i = 0;
  27:sysfunc.h     **** 	while (buff[i] != 0) {
 532               		.loc 4 27 0
 533 01b4 FC01      		movw r30,r24
 534               	.LVL39:
 535               	.L49:
 536 01b6 9F01      		movw r18,r30
 537 01b8 281B      		sub r18,r24
 538 01ba 390B      		sbc r19,r25
 539               	.LVL40:
 540               		.loc 4 27 0 is_stmt 0 discriminator 1
 541 01bc 4191      		ld r20,Z+
 542 01be 4111      		cpse r20,__zero_reg__
 543 01c0 00C0      		rjmp .L49
  28:sysfunc.h     **** 		i += 1;
  29:sysfunc.h     **** 	}
  30:sysfunc.h     **** 	return i;
  31:sysfunc.h     **** }
 544               		.loc 4 31 0 is_stmt 1
 545 01c2 C901      		movw r24,r18
 546               	.LVL41:
 547 01c4 0895      		ret
 548               		.cfi_endproc
 549               	.LFE19:
 551               	.global	delay_ms
 553               	delay_ms:
 554               	.LFB20:
  32:sysfunc.h     **** 
  33:sysfunc.h     **** void delay_ms(int ms)
  34:sysfunc.h     **** {
 555               		.loc 4 34 0
 556               		.cfi_startproc
 557               	.LVL42:
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
 562               	.L52:
  35:sysfunc.h     ****   while (0 < ms)
 563               		.loc 4 35 0 discriminator 1
 564 01c6 1816      		cp __zero_reg__,r24
 565 01c8 1906      		cpc __zero_reg__,r25
 566 01ca 04F4      		brge .L54
 567               	.LVL43:
 568               	.LBB62:
 569               	.LBB63:
 570               		.file 5 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 571               		.loc 5 163 0
 572 01cc EFE9      		ldi r30,lo8(3999)
 573 01ce FFE0      		ldi r31,hi8(3999)
 574 01d0 3197      		1: sbiw r30,1
 575 01d2 01F4      		brne 1b
 576 01d4 00C0      		rjmp .
 577 01d6 0000      		nop
 578               	.LBE63:
 579               	.LBE62:
  36:sysfunc.h     ****   {
  37:sysfunc.h     ****     _delay_ms(1);
  38:sysfunc.h     ****     --ms;
 580               		.loc 4 38 0
 581 01d8 0197      		sbiw r24,1
 582               	.LVL44:
 583 01da 00C0      		rjmp .L52
 584               	.LVL45:
 585               	.L54:
 586               	/* epilogue start */
  39:sysfunc.h     ****   }
  40:sysfunc.h     **** }
 587               		.loc 4 40 0
 588 01dc 0895      		ret
 589               		.cfi_endproc
 590               	.LFE20:
 592               	.global	WriteByte
 594               	WriteByte:
 595               	.LFB21:
 596               		.file 6 "LCDMelt.h"
   1:LCDMelt.h     **** /*
   2:LCDMelt.h     ****  * LCDMelt.h
   3:LCDMelt.h     ****  *
   4:LCDMelt.h     ****  *  Created on: 03.10.2015
   5:LCDMelt.h     ****  *      Author: anton
   6:LCDMelt.h     ****  ************************************************************************
   7:LCDMelt.h     ****  * 				–ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å LCD Melt 15S2
   8:LCDMelt.h     ****  ************************************************************************
   9:LCDMelt.h     ****  */
  10:LCDMelt.h     **** 
  11:LCDMelt.h     **** 
  12:LCDMelt.h     **** /*
  13:LCDMelt.h     ****  *  							–ê–õ–§–ê–í–ò–¢ –ú–≠–õ–¢
  14:LCDMelt.h     ****  *
  15:LCDMelt.h     ****  * 	  –ê   –∞   –ë   –±   –í   –≤   –ì   –≥   –î   –¥   –ï   –µ   –Å   —ë   –ñ   –∂
  16:LCDMelt.h     ****  * "\xC0\xE0\xC1\xE1\xC2\xE2\xC3\xE3\xC4\xE4\xC5\xE5\xA8\xB8\xC6\xE6"
  17:LCDMelt.h     ****  *
  18:LCDMelt.h     ****  *    –ó   –∑   –ò   –∏   –ô   –π   –ö   –∫   –õ   –ª   –ú   –º   –ù   –Ω   –û   –æ
  19:LCDMelt.h     ****  * "\xC7\xE7\xC8\xE8\xC9\xE9\xCA\xEA\xCB\xEB\xCC\xEC\xCD\xED\xCE\xEE"
  20:LCDMelt.h     ****  *
  21:LCDMelt.h     ****  *    –ü   –ø   –†   —Ä   –°   —Å   –¢   —Ç   –£   —É   –§   —Ñ   –•   —Ö   –¶   —Ü
  22:LCDMelt.h     ****  * "\xCF\xEF\xD0\xF0\xD1\xF1\xD2\xF2\xD3\xF3\xD4\xF4\xD5\xF5\xD6\xF6"
  23:LCDMelt.h     ****  *
  24:LCDMelt.h     ****  *    –ß   —á   –®   —à   –©   —â   –™   —ä   –´   —ã   –¨   —å   –≠   —ç   –Æ   —é
  25:LCDMelt.h     ****  * "\xD7\xF7\xD8\xF8\xD9\xF9\xDA\xFA\xDB\xFB\xDC\xFC\xDD\xFD\xDE\xFE"
  26:LCDMelt.h     ****  *
  27:LCDMelt.h     ****  *    –Ø   —è
  28:LCDMelt.h     ****  * "\xDF\xFF"
  29:LCDMelt.h     ****  *
  30:LCDMelt.h     ****  */
  31:LCDMelt.h     **** 
  32:LCDMelt.h     **** #ifndef LCDMELT_H_
  33:LCDMelt.h     **** #define LCDMELT_H_
  34:LCDMelt.h     **** 
  35:LCDMelt.h     **** #include <avr/io.h>
  36:LCDMelt.h     **** #include <util/delay.h>
  37:LCDMelt.h     **** #include "sysfunc.h"
  38:LCDMelt.h     **** 
  39:LCDMelt.h     **** #define MAX_LCD_LINE 16
  40:LCDMelt.h     **** 
  41:LCDMelt.h     **** #define byte char
  42:LCDMelt.h     **** #define bit_test(var, bitno)((var) & 1 << (bitno))
  43:LCDMelt.h     **** #define LCD_E_CLR (PORTB &= ~(1 << P_E))
  44:LCDMelt.h     **** #define LCD_E_SET (PORTB |= (1 << P_E))
  45:LCDMelt.h     **** #define LCD_A0_CLR (PORTB &= ~(1 << P_A0))
  46:LCDMelt.h     **** #define LCD_A0_SET (PORTB |= (1 << P_A0))
  47:LCDMelt.h     **** 
  48:LCDMelt.h     **** // –°–∏–º–≤–æ–ª—ã
  49:LCDMelt.h     **** #define SYMB_ARROW_RIGHT "\x90"
  50:LCDMelt.h     **** #define SYMB_SPACE "\x20"
  51:LCDMelt.h     **** 
  52:LCDMelt.h     **** // –õ–∏–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ñ–ö–ò —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∞ –≤ PD
  53:LCDMelt.h     **** #define P_DB7	7
  54:LCDMelt.h     **** #define P_DB6	6
  55:LCDMelt.h     **** #define P_DB5	5
  56:LCDMelt.h     **** #define P_DB4	4
  57:LCDMelt.h     **** #define P_DB3	3
  58:LCDMelt.h     **** #define P_DB2	2
  59:LCDMelt.h     **** #define P_DB1	1
  60:LCDMelt.h     **** #define P_DB0	0
  61:LCDMelt.h     **** 
  62:LCDMelt.h     **** // –õ–∏–Ω–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ñ–ö–ò —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∞ –≤ PB, RW –≤—Å–µ–≥–¥–∞ –Ω—É
  63:LCDMelt.h     **** #define P_E		0
  64:LCDMelt.h     **** #define P_A0	1
  65:LCDMelt.h     **** 
  66:LCDMelt.h     **** void WriteByte(byte b, byte /*bit*/cd) {
 597               		.loc 6 66 0
 598               		.cfi_startproc
 599               	.LVL46:
 600               	/* prologue: function */
 601               	/* frame size = 0 */
 602               	/* stack size = 0 */
 603               	.L__stack_usage = 0
 604               	.LBB64:
 605               	.LBB65:
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 606               		.loc 5 245 0
 607 01de 95ED      		ldi r25,lo8(-43)
 608 01e0 9A95      		1: dec r25
 609 01e2 01F4      		brne 1b
 610 01e4 0000      		nop
 611               	.LBE65:
 612               	.LBE64:
  67:LCDMelt.h     **** // –ó–∞–ø–∏—Å–∞—Ç—å –±–∞–π—Ç –¥–∞–Ω–Ω—ã—Ö –≤ —ç–∫—Ä–∞–Ω
  68:LCDMelt.h     **** 
  69:LCDMelt.h     ****     _delay_us(40);
  70:LCDMelt.h     ****     if (cd == 1) {
 613               		.loc 6 70 0
 614 01e6 6130      		cpi r22,lo8(1)
 615 01e8 01F4      		brne .L56
  71:LCDMelt.h     ****         LCD_A0_SET;
 616               		.loc 6 71 0
 617 01ea C19A      		sbi 0x18,1
 618 01ec 00C0      		rjmp .L57
 619               	.L56:
  72:LCDMelt.h     ****     } else {
  73:LCDMelt.h     ****         LCD_A0_CLR;
 620               		.loc 6 73 0
 621 01ee C198      		cbi 0x18,1
 622               	.L57:
  74:LCDMelt.h     ****     }
  75:LCDMelt.h     **** 
  76:LCDMelt.h     **** 
  77:LCDMelt.h     ****     if (b & (1 << 7 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 623               		.loc 6 77 0
 624 01f0 87FF      		sbrs r24,7
 625 01f2 00C0      		rjmp .L58
  78:LCDMelt.h     ****         PORTD |= (1 << 7);
 626               		.loc 6 78 0
 627 01f4 979A      		sbi 0x12,7
 628 01f6 00C0      		rjmp .L59
 629               	.L58:
  79:LCDMelt.h     ****     } else {
  80:LCDMelt.h     ****         PORTD &= ~(1 << 7);
 630               		.loc 6 80 0
 631 01f8 9798      		cbi 0x12,7
 632               	.L59:
  81:LCDMelt.h     ****     }
  82:LCDMelt.h     ****     if (b & (1 << 6 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 633               		.loc 6 82 0
 634 01fa 86FF      		sbrs r24,6
 635 01fc 00C0      		rjmp .L60
  83:LCDMelt.h     ****         PORTD |= (1 << 6);
 636               		.loc 6 83 0
 637 01fe 969A      		sbi 0x12,6
 638 0200 00C0      		rjmp .L61
 639               	.L60:
  84:LCDMelt.h     ****     } else {
  85:LCDMelt.h     ****         PORTD &= ~(1 << 6);
 640               		.loc 6 85 0
 641 0202 9698      		cbi 0x12,6
 642               	.L61:
  86:LCDMelt.h     ****     }
  87:LCDMelt.h     ****     if (b & (1 << 5 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 643               		.loc 6 87 0
 644 0204 85FF      		sbrs r24,5
 645 0206 00C0      		rjmp .L62
  88:LCDMelt.h     ****         PORTD |= (1 << 5);
 646               		.loc 6 88 0
 647 0208 959A      		sbi 0x12,5
 648 020a 00C0      		rjmp .L63
 649               	.L62:
  89:LCDMelt.h     ****     } else {
  90:LCDMelt.h     ****         PORTD &= ~(1 << 5);
 650               		.loc 6 90 0
 651 020c 9598      		cbi 0x12,5
 652               	.L63:
  91:LCDMelt.h     ****     }
  92:LCDMelt.h     ****     if (b & (1 << 4 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 653               		.loc 6 92 0
 654 020e 84FF      		sbrs r24,4
 655 0210 00C0      		rjmp .L64
  93:LCDMelt.h     ****         PORTD |= (1 << 4);
 656               		.loc 6 93 0
 657 0212 949A      		sbi 0x12,4
 658 0214 00C0      		rjmp .L65
 659               	.L64:
  94:LCDMelt.h     ****     } else {
  95:LCDMelt.h     ****         PORTD &= ~(1 << 4);
 660               		.loc 6 95 0
 661 0216 9498      		cbi 0x12,4
 662               	.L65:
 663               	.LVL47:
 664               	.LBB66:
 665               	.LBB67:
 666               		.loc 5 245 0
 667 0218 95E0      		ldi r25,lo8(5)
 668 021a 9A95      		1: dec r25
 669 021c 01F4      		brne 1b
 670 021e 0000      		nop
 671               	.LBE67:
 672               	.LBE66:
  96:LCDMelt.h     ****     }
  97:LCDMelt.h     ****     _delay_us(1); //–≠—Ç–æ –≤—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–¥—Ä–µ—Å–∞ (tAS)
  98:LCDMelt.h     ****     LCD_E_SET;
 673               		.loc 6 98 0
 674 0220 C09A      		sbi 0x18,0
 675               	.LVL48:
 676               	.LBB68:
 677               	.LBB69:
 678               		.loc 5 245 0
 679 0222 95E0      		ldi r25,lo8(5)
 680 0224 9A95      		1: dec r25
 681 0226 01F4      		brne 1b
 682 0228 0000      		nop
 683               	.LBE69:
 684               	.LBE68:
  99:LCDMelt.h     ****     _delay_us(1); //–í—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ø–∞–ª–æ —Å—é–¥–∞ (tDSW)
 100:LCDMelt.h     ****     LCD_E_CLR;
 685               		.loc 6 100 0
 686 022a C098      		cbi 0x18,0
 687               	.LVL49:
 688               	.LBB70:
 689               	.LBB71:
 690               		.loc 5 245 0
 691 022c 95E0      		ldi r25,lo8(5)
 692 022e 9A95      		1: dec r25
 693 0230 01F4      		brne 1b
 694 0232 0000      		nop
 695               	.LBE71:
 696               	.LBE70:
 101:LCDMelt.h     ****     _delay_us(1); //–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É —Å–∏–≥–Ω–
 102:LCDMelt.h     **** 
 103:LCDMelt.h     ****     if (b & (1 << 3 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 697               		.loc 6 103 0
 698 0234 83FF      		sbrs r24,3
 699 0236 00C0      		rjmp .L66
 104:LCDMelt.h     ****         PORTD |= (1 << 7);
 700               		.loc 6 104 0
 701 0238 979A      		sbi 0x12,7
 702 023a 00C0      		rjmp .L67
 703               	.L66:
 105:LCDMelt.h     ****     } else {
 106:LCDMelt.h     ****         PORTD &= ~(1 << 7);
 704               		.loc 6 106 0
 705 023c 9798      		cbi 0x12,7
 706               	.L67:
 107:LCDMelt.h     ****     }
 108:LCDMelt.h     ****     if (b & (1 << 2 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 707               		.loc 6 108 0
 708 023e 82FF      		sbrs r24,2
 709 0240 00C0      		rjmp .L68
 109:LCDMelt.h     ****         PORTD |= (1 << 6);
 710               		.loc 6 109 0
 711 0242 969A      		sbi 0x12,6
 712 0244 00C0      		rjmp .L69
 713               	.L68:
 110:LCDMelt.h     ****     } else {
 111:LCDMelt.h     ****         PORTD &= ~(1 << 6);
 714               		.loc 6 111 0
 715 0246 9698      		cbi 0x12,6
 716               	.L69:
 112:LCDMelt.h     ****     }
 113:LCDMelt.h     ****     if (b & (1 << 1 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 717               		.loc 6 113 0
 718 0248 81FF      		sbrs r24,1
 719 024a 00C0      		rjmp .L70
 114:LCDMelt.h     ****         PORTD |= (1 << 5);
 720               		.loc 6 114 0
 721 024c 959A      		sbi 0x12,5
 722 024e 00C0      		rjmp .L71
 723               	.L70:
 115:LCDMelt.h     ****     } else {
 116:LCDMelt.h     ****         PORTD &= ~(1 << 5);
 724               		.loc 6 116 0
 725 0250 9598      		cbi 0x12,5
 726               	.L71:
 117:LCDMelt.h     ****     }
 118:LCDMelt.h     ****     if (b & (1 << 0 /*–ø–æ–∑–∏—Ü–∏—è –±–∏—Ç–∞*/)) {
 727               		.loc 6 118 0
 728 0252 80FF      		sbrs r24,0
 729 0254 00C0      		rjmp .L72
 119:LCDMelt.h     ****         PORTD |= (1 << 4);
 730               		.loc 6 119 0
 731 0256 949A      		sbi 0x12,4
 732 0258 00C0      		rjmp .L73
 733               	.L72:
 120:LCDMelt.h     ****     } else {
 121:LCDMelt.h     ****         PORTD &= ~(1 << 4);
 734               		.loc 6 121 0
 735 025a 9498      		cbi 0x12,4
 736               	.L73:
 737               	.LVL50:
 738               	.LBB72:
 739               	.LBB73:
 740               		.loc 5 245 0
 741 025c 85E0      		ldi r24,lo8(5)
 742 025e 8A95      		1: dec r24
 743 0260 01F4      		brne 1b
 744               	.LVL51:
 745 0262 0000      		nop
 746               	.LBE73:
 747               	.LBE72:
 122:LCDMelt.h     ****     }
 123:LCDMelt.h     **** 
 124:LCDMelt.h     ****     _delay_us(1); //–≠—Ç–æ –≤—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–¥—Ä–µ—Å–∞ (tAS)
 125:LCDMelt.h     ****     LCD_E_SET;
 748               		.loc 6 125 0
 749 0264 C09A      		sbi 0x18,0
 750               	.LVL52:
 751               	.LBB74:
 752               	.LBB75:
 753               		.loc 5 245 0
 754 0266 95E0      		ldi r25,lo8(5)
 755 0268 9A95      		1: dec r25
 756 026a 01F4      		brne 1b
 757 026c 0000      		nop
 758               	.LBE75:
 759               	.LBE74:
 126:LCDMelt.h     ****     _delay_us(1); //–í—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ø–∞–ª–æ —Å—é–¥–∞ (tDSW)
 127:LCDMelt.h     ****     LCD_E_CLR;
 760               		.loc 6 127 0
 761 026e C098      		cbi 0x18,0
 762               	.LVL53:
 763               	.LBB76:
 764               	.LBB77:
 765               		.loc 5 245 0
 766 0270 85E0      		ldi r24,lo8(5)
 767 0272 8A95      		1: dec r24
 768 0274 01F4      		brne 1b
 769 0276 0000      		nop
 770 0278 0895      		ret
 771               	.LBE77:
 772               	.LBE76:
 773               		.cfi_endproc
 774               	.LFE21:
 776               	.global	WriteCmd
 778               	WriteCmd:
 779               	.LFB22:
 128:LCDMelt.h     ****     _delay_us(1); //–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É —Å–∏–≥–Ω–
 129:LCDMelt.h     **** 
 130:LCDMelt.h     ****     /*–ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∑–¥–µ—Å—å —à–∏–Ω—É –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤
 131:LCDMelt.h     ****         LCD.RW=0; LCD.A0=cd; LCD.D=b>>4;
 132:LCDMelt.h     ****         Delay(>40ns);		//–≠—Ç–æ –≤—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–¥—Ä–µ—Å–∞ (tAS)
 133:LCDMelt.h     ****         LCD.E=1; Delay(>230ns);	//–í—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ø–∞–ª–æ —
 134:LCDMelt.h     ****         LCD.E=0; Delay(>270ns);	//–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂
 135:LCDMelt.h     ****         LCD.D=b&0x0F;		//–í—ã–¥–∞–¥–∏–º –º–ª–∞–¥—à–∏–µ 4 –±–∏—Ç–∞ (–ø—Ä–∏ —ç—Ç–æ–º –±–∏—Ç—ã RW –∏ A
 136:LCDMelt.h     ****         LCD.E=1; Delay(>230ns);	//–í—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ø–∞–ª–æ —
 137:LCDMelt.h     ****         LCD.E=0; Delay(>270ns);	//–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂
 138:LCDMelt.h     **** 
 139:LCDMelt.h     **** 
 140:LCDMelt.h     ****      **
 141:LCDMelt.h     ****      * 8 –±–∏—Ç–Ω—ã–π —Ä–µ–∂–∏–º, —Ä–∞–±–æ—Ç–∞–µ—Ç
 142:LCDMelt.h     ****      **
 143:LCDMelt.h     ****     _delay_us(40);
 144:LCDMelt.h     **** 	//LCD.RW = 0;
 145:LCDMelt.h     **** 	if (cd == 1) {
 146:LCDMelt.h     **** 		LCD_A0_SET;
 147:LCDMelt.h     **** 	} else {
 148:LCDMelt.h     **** 		LCD_A0_CLR;
 149:LCDMelt.h     **** 	}
 150:LCDMelt.h     **** 	PORTD = b;
 151:LCDMelt.h     **** 	_delay_us(1); //–≠—Ç–æ –≤—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–¥—Ä–µ—Å–∞ (tAS)
 152:LCDMelt.h     **** 	LCD_E_SET;
 153:LCDMelt.h     **** 	_delay_us(1); //–í—Ä–µ–º—è –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ø–∞–ª–æ —Å—é–¥–∞ (tDSW)
 154:LCDMelt.h     **** 	LCD_E_CLR;
 155:LCDMelt.h     **** 	_delay_us(1); //–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É —Å–∏–≥–Ω–∞–ª
 156:LCDMelt.h     **** 
 157:LCDMelt.h     ****     */
 158:LCDMelt.h     **** }
 159:LCDMelt.h     **** 
 160:LCDMelt.h     **** void WriteCmd(byte b) {
 780               		.loc 6 160 0
 781               		.cfi_startproc
 782               	.LVL54:
 783               	/* prologue: function */
 784               	/* frame size = 0 */
 785               	/* stack size = 0 */
 786               	.L__stack_usage = 0
 161:LCDMelt.h     **** 	// –ü–µ—Ä–µ–¥–∞—ë–º –∫–æ–º–∞–Ω–¥—É –≤ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —ç–∫—Ä–∞–Ω–∞
 162:LCDMelt.h     **** 	WriteByte(b, 0);
 787               		.loc 6 162 0
 788 027a 60E0      		ldi r22,0
 789 027c 00C0      		rjmp WriteByte
 790               	.LVL55:
 791               		.cfi_endproc
 792               	.LFE22:
 794               	.global	WriteData
 796               	WriteData:
 797               	.LFB23:
 163:LCDMelt.h     **** }
 164:LCDMelt.h     **** 
 165:LCDMelt.h     **** void WriteData(byte b) {
 798               		.loc 6 165 0
 799               		.cfi_startproc
 800               	.LVL56:
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 803               	/* stack size = 0 */
 804               	.L__stack_usage = 0
 166:LCDMelt.h     **** 	// –ü–µ—Ä–µ–¥–∞—ë–º —Å–∏–º–≤–æ–ª –≤ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —ç–∫—Ä–∞–Ω–∞
 167:LCDMelt.h     **** 	WriteByte(b, 1);
 805               		.loc 6 167 0
 806 027e 61E0      		ldi r22,lo8(1)
 807 0280 00C0      		rjmp WriteByte
 808               	.LVL57:
 809               		.cfi_endproc
 810               	.LFE23:
 812               	.global	LCDinit
 814               	LCDinit:
 815               	.LFB24:
 168:LCDMelt.h     **** }
 169:LCDMelt.h     **** 
 170:LCDMelt.h     **** void LCDinit(void) {
 816               		.loc 6 170 0
 817               		.cfi_startproc
 818               	/* prologue: function */
 819               	/* frame size = 0 */
 820               	/* stack size = 0 */
 821               	.L__stack_usage = 0
 171:LCDMelt.h     **** 	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏—Å–ø–ª–µ—è
 172:LCDMelt.h     **** 
 173:LCDMelt.h     ****     LCD_E_CLR;
 822               		.loc 6 173 0
 823 0282 C098      		cbi 0x18,0
 824               	.LVL58:
 825               	.LBB78:
 826               	.LBB79:
 163:/usr/lib/avr/include/util/delay.h **** 
 827               		.loc 5 163 0
 828 0284 2FEF      		ldi r18,lo8(63999)
 829 0286 89EF      		ldi r24,hi8(63999)
 830 0288 90E0      		ldi r25,hlo8(63999)
 831 028a 2150      		1: subi r18,1
 832 028c 8040      		sbci r24,0
 833 028e 9040      		sbci r25,0
 834 0290 01F4      		brne 1b
 835 0292 00C0      		rjmp .
 836 0294 0000      		nop
 837               	.LBE79:
 838               	.LBE78:
 174:LCDMelt.h     ****     _delay_ms(20);
 175:LCDMelt.h     ****     LCD_A0_CLR;
 839               		.loc 6 175 0
 840 0296 C198      		cbi 0x18,1
 176:LCDMelt.h     ****     WriteCmd(0x20); //–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º 4-—Ö –±–∏—Ç–Ω—ã–π —Ä–µ–∂–∏–º
 841               		.loc 6 176 0
 842 0298 80E2      		ldi r24,lo8(32)
 843 029a 00D0      		rcall WriteCmd
 844               	.LVL59:
 177:LCDMelt.h     ****     WriteCmd(0x2A); //–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ –ñ–ö–ò
 845               		.loc 6 177 0
 846 029c 8AE2      		ldi r24,lo8(42)
 847 029e 00D0      		rcall WriteCmd
 848               	.LVL60:
 178:LCDMelt.h     ****     WriteCmd(0x0C); //–í–∫–ª—é—á–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞, –∫—É—Ä—Å–æ—Ä –≤—ã–∫–ª—é—á–µ–Ω
 849               		.loc 6 178 0
 850 02a0 8CE0      		ldi r24,lo8(12)
 851 02a2 00D0      		rcall WriteCmd
 852               	.LVL61:
 179:LCDMelt.h     ****     WriteCmd(0x01); //–û—á–∏—Å—Ç–∫–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
 853               		.loc 6 179 0
 854 02a4 81E0      		ldi r24,lo8(1)
 855 02a6 00D0      		rcall WriteCmd
 856               	.LVL62:
 857               	.LBB80:
 858               	.LBB81:
 163:/usr/lib/avr/include/util/delay.h **** 
 859               		.loc 5 163 0
 860 02a8 8FE6      		ldi r24,lo8(5999)
 861 02aa 97E1      		ldi r25,hi8(5999)
 862 02ac 0197      		1: sbiw r24,1
 863 02ae 01F4      		brne 1b
 864 02b0 00C0      		rjmp .
 865 02b2 0000      		nop
 866               	.LBE81:
 867               	.LBE80:
 180:LCDMelt.h     ****     _delay_ms(1.5);
 181:LCDMelt.h     ****     WriteCmd(0x06); //–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–∂–∏–º–∞ –≤–≤–æ–¥–∞ –¥–∞–Ω–Ω—ã—Ö: —Å–¥–≤–∏–≥–∞—Ç—å –∫—
 868               		.loc 6 181 0
 869 02b4 86E0      		ldi r24,lo8(6)
 870 02b6 00C0      		rjmp WriteCmd
 871               	.LVL63:
 872               		.cfi_endproc
 873               	.LFE24:
 875               	.global	LCDFirstLine
 877               	LCDFirstLine:
 878               	.LFB25:
 182:LCDMelt.h     **** 
 183:LCDMelt.h     **** /**
 184:LCDMelt.h     ****  * 8 –±–∏—Ç–Ω—ã–π —Ä–µ–∂–∏–º, —Ä–∞–±–æ—Ç–∞–µ—Ç
 185:LCDMelt.h     ****  *
 186:LCDMelt.h     **** 	LCD_E_CLR;
 187:LCDMelt.h     **** 	_delay_ms(20);
 188:LCDMelt.h     **** //–ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∑–¥–µ—Å—å —à–∏–Ω—É –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤—ã–≤
 189:LCDMelt.h     **** //LCD.RW = 0; –≤—Å–µ–≥–¥–∞ –Ω—É–ª—å
 190:LCDMelt.h     **** 	LCD_A0_CLR;
 191:LCDMelt.h     **** 	WriteCmd(0x30);
 192:LCDMelt.h     ****     //WriteCmd(0x30);
 193:LCDMelt.h     ****     //WriteCmd(0x30);
 194:LCDMelt.h     **** //–ó–¥–µ—Å—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤—Ö–æ–¥–∏—Ç –≤ —Ä–∞–±–æ—á–∏–π —Ä–µ–∂–∏–º —Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω
 195:LCDMelt.h     **** 	WriteCmd(0x3A); //–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ –ñ–ö–ò
 196:LCDMelt.h     **** 	WriteCmd(0x0C); //–í–∫–ª—é—á–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞, –∫—É—Ä—Å–æ—Ä –≤—ã–∫–ª—é—á–µ–Ω
 197:LCDMelt.h     **** 	WriteCmd(0x01); //–û—á–∏—Å—Ç–∫–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
 198:LCDMelt.h     **** 	_delay_ms(1.5);
 199:LCDMelt.h     **** 	WriteCmd(0x06); //–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–∂–∏–º–∞ –≤–≤–æ–¥–∞ –¥–∞–Ω–Ω—ã—Ö: —Å–¥–≤–∏–≥–∞—Ç—å –∫—É—Ä
 200:LCDMelt.h     ****   **/
 201:LCDMelt.h     **** }
 202:LCDMelt.h     **** 
 203:LCDMelt.h     **** void LCDFirstLine() {
 879               		.loc 6 203 0
 880               		.cfi_startproc
 881               	/* prologue: function */
 882               	/* frame size = 0 */
 883               	/* stack size = 0 */
 884               	.L__stack_usage = 0
 204:LCDMelt.h     **** 	// –ü–µ—Ä–µ–≤–æ–¥–∏–º –∫—É—Ä—Å–æ—Ä –≤ –Ω–∞—á–∞–ª–æ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏
 205:LCDMelt.h     **** 
 206:LCDMelt.h     **** 	WriteCmd(0x80); //–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫—É—Ä—Å–æ—Ä–∞ –≤ –Ω–∞—á–∞–ª–æ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –∏–Ω
 885               		.loc 6 206 0
 886 02b8 80E8      		ldi r24,lo8(-128)
 887 02ba 00D0      		rcall WriteCmd
 888               	.LVL64:
 889               	.LBB82:
 890               	.LBB83:
 163:/usr/lib/avr/include/util/delay.h **** 
 891               		.loc 5 163 0
 892 02bc 8FE6      		ldi r24,lo8(5999)
 893 02be 97E1      		ldi r25,hi8(5999)
 894 02c0 0197      		1: sbiw r24,1
 895 02c2 01F4      		brne 1b
 896 02c4 00C0      		rjmp .
 897 02c6 0000      		nop
 898 02c8 0895      		ret
 899               	.LBE83:
 900               	.LBE82:
 901               		.cfi_endproc
 902               	.LFE25:
 904               	.global	LCDLastLine
 906               	LCDLastLine:
 907               	.LFB26:
 207:LCDMelt.h     **** 	_delay_ms(1.5);
 208:LCDMelt.h     **** }
 209:LCDMelt.h     **** 
 210:LCDMelt.h     **** void LCDLastLine() {
 908               		.loc 6 210 0
 909               		.cfi_startproc
 910               	/* prologue: function */
 911               	/* frame size = 0 */
 912               	/* stack size = 0 */
 913               	.L__stack_usage = 0
 211:LCDMelt.h     **** 	// –ü–µ—Ä–µ–≤–æ–¥–∏–º –∫—É—Ä—Å–æ—Ä –≤ –Ω–∞—á–∞–ª–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–∏
 212:LCDMelt.h     **** 
 213:LCDMelt.h     **** 	LCDFirstLine();
 914               		.loc 6 213 0
 915 02ca 00D0      		rcall LCDFirstLine
 916               	.LVL65:
 214:LCDMelt.h     **** 	WriteCmd(0x80 + 0x40); //–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫—É—Ä—Å–æ—Ä–∞ –≤ –Ω–∞—á–∞–ª–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫
 917               		.loc 6 214 0
 918 02cc 80EC      		ldi r24,lo8(-64)
 919 02ce 00D0      		rcall WriteCmd
 920               	.LVL66:
 921               	.LBB84:
 922               	.LBB85:
 163:/usr/lib/avr/include/util/delay.h **** 
 923               		.loc 5 163 0
 924 02d0 8FE6      		ldi r24,lo8(5999)
 925 02d2 97E1      		ldi r25,hi8(5999)
 926 02d4 0197      		1: sbiw r24,1
 927 02d6 01F4      		brne 1b
 928 02d8 00C0      		rjmp .
 929 02da 0000      		nop
 930 02dc 0895      		ret
 931               	.LBE85:
 932               	.LBE84:
 933               		.cfi_endproc
 934               	.LFE26:
 936               	.global	LCDClrScr
 938               	LCDClrScr:
 939               	.LFB27:
 215:LCDMelt.h     **** 	_delay_ms(1.5);
 216:LCDMelt.h     **** }
 217:LCDMelt.h     **** 
 218:LCDMelt.h     **** void LCDClrScr() {
 940               		.loc 6 218 0
 941               		.cfi_startproc
 942               	/* prologue: function */
 943               	/* frame size = 0 */
 944               	/* stack size = 0 */
 945               	.L__stack_usage = 0
 219:LCDMelt.h     **** 	//–û—á–∏—Å—Ç–∫–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
 220:LCDMelt.h     **** 
 221:LCDMelt.h     **** 	WriteCmd(0x01);
 946               		.loc 6 221 0
 947 02de 81E0      		ldi r24,lo8(1)
 948 02e0 00D0      		rcall WriteCmd
 949               	.LVL67:
 950               	.LBB86:
 951               	.LBB87:
 163:/usr/lib/avr/include/util/delay.h **** 
 952               		.loc 5 163 0
 953 02e2 8FE6      		ldi r24,lo8(5999)
 954 02e4 97E1      		ldi r25,hi8(5999)
 955 02e6 0197      		1: sbiw r24,1
 956 02e8 01F4      		brne 1b
 957 02ea 00C0      		rjmp .
 958 02ec 0000      		nop
 959 02ee 0895      		ret
 960               	.LBE87:
 961               	.LBE86:
 962               		.cfi_endproc
 963               	.LFE27:
 965               	.global	LCDPrint
 967               	LCDPrint:
 968               	.LFB28:
 222:LCDMelt.h     **** 	_delay_ms(1.5);
 223:LCDMelt.h     **** }
 224:LCDMelt.h     **** 
 225:LCDMelt.h     **** void LCDPrint(char str[]) {
 969               		.loc 6 225 0
 970               		.cfi_startproc
 971               	.LVL68:
 972 02f0 CF93      		push r28
 973               	.LCFI5:
 974               		.cfi_def_cfa_offset 3
 975               		.cfi_offset 28, -2
 976 02f2 DF93      		push r29
 977               	.LCFI6:
 978               		.cfi_def_cfa_offset 4
 979               		.cfi_offset 29, -3
 980               	/* prologue: function */
 981               	/* frame size = 0 */
 982               	/* stack size = 2 */
 983               	.L__stack_usage = 2
 984 02f4 EC01      		movw r28,r24
 985               	.LVL69:
 986               	.L81:
 226:LCDMelt.h     **** 	// –ü–µ—á–∞—Ç–∞–µ–º —Å—Ç—Ä–æ–∫—É –Ω–∞ —ç–∫—Ä–∞–Ω–µ
 227:LCDMelt.h     **** 
 228:LCDMelt.h     **** 	int i = 0;
 229:LCDMelt.h     **** 	while (str[i] != '\x00') {
 987               		.loc 6 229 0 discriminator 1
 988 02f6 8991      		ld r24,Y+
 989               	.LVL70:
 990 02f8 8823      		tst r24
 991 02fa 01F0      		breq .L83
 230:LCDMelt.h     **** 		WriteData(str[i]);
 992               		.loc 6 230 0
 993 02fc 00D0      		rcall WriteData
 994               	.LVL71:
 995 02fe 00C0      		rjmp .L81
 996               	.LVL72:
 997               	.L83:
 998               	/* epilogue start */
 231:LCDMelt.h     **** 		i += 1;
 232:LCDMelt.h     **** 	}
 233:LCDMelt.h     **** }
 999               		.loc 6 233 0
 1000 0300 DF91      		pop r29
 1001 0302 CF91      		pop r28
 1002               	.LVL73:
 1003 0304 0895      		ret
 1004               		.cfi_endproc
 1005               	.LFE28:
 1007               	.global	LCDReturnHome
 1009               	LCDReturnHome:
 1010               	.LFB29:
 234:LCDMelt.h     **** 
 235:LCDMelt.h     **** /* –ù–µ –ø—Ä–æ–∫–∞—Ç–∏–ª–æ((((
 236:LCDMelt.h     ****  *
 237:LCDMelt.h     **** void LCDPrintRu(char str[]) {
 238:LCDMelt.h     **** 
 239:LCDMelt.h     **** #define SYMB_COUNT 66
 240:LCDMelt.h     **** 	// –ü–µ—á–∞—Ç–∞–µ–º —Ä—É—Å—Å–∫—É—é —Å—Ç—Ä–æ–∫—É –Ω–∞ —ç–∫—Ä–∞–Ω–µ
 241:LCDMelt.h     **** 
 242:LCDMelt.h     **** 	char local_ru[] =
 243:LCDMelt.h     **** 			"–ê–∞–ë–±–í–≤–ì–≥–î–¥–ï–µ–Å—ë–ñ–∂–ó–∑–ò–∏–ô–π–ö–∫–õ–ª–ú–º–ù–Ω–û–æ–ü–ø–†—Ä–°—Å–¢—Ç–£—É–§—Ñ–•—Ö–¶—
 244:LCDMelt.h     **** 	char local_melt[] =
 245:LCDMelt.h     **** 			"\xC0\xE0\xC1\xE1\xC2\xE2\xC3\xE3\xC4\xE4\xC5\xE5\xA8\xB8\xC6\xE6" // –ê–∞–ë–±–í–≤–ì–≥–î–¥–ï–µ–Å
 246:LCDMelt.h     **** 					"\xC7\xE7\xC8\xE8\xC9\xE9\xCA\xEA\xCB\xEB\xCC\xEC\xCD\xED\xCE\xEE"// –ó–∑–ò–∏–ô–π–ö–∫–õ–ª–ú–º–
 247:LCDMelt.h     **** 					"\xCF\xEF\xD0\xF0\xD1\xF1\xD2\xF2\xD3\xF3\xD4\xF4\xD5\xF5\xD6\xF6"// –ü–ø–†—Ä–°—Å–¢—Ç–£—É–§—Ñ–
 248:LCDMelt.h     **** 					"\xD7\xF7\xD8\xF8\xD9\xF9\xDA\xFA\xDB\xFB\xDC\xFC\xDD\xFD\xDE\xFE"// –ß—á–®—à–©—â–™—ä–´—ã–¨—å–
 249:LCDMelt.h     **** 					"\xDF\xFF";// –Ø—è
 250:LCDMelt.h     **** 
 251:LCDMelt.h     **** 	// –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º—É —Ç–µ–∫—Å—Ç—É
 252:LCDMelt.h     **** 	for (int i = 0; i < 16; i++) {
 253:LCDMelt.h     **** 
 254:LCDMelt.h     **** 		// –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –Ω–∞—Ç–∫–Ω—É–ª–∏—Å—å –ª–∏ –º—ã –Ω–∞ –∫–æ–Ω–µ—Ü —Å—Ç—Ä–æ–∫–∏
 255:LCDMelt.h     **** 		if (str[i] == 0) {
 256:LCDMelt.h     **** 			break;
 257:LCDMelt.h     **** 		}
 258:LCDMelt.h     **** 
 259:LCDMelt.h     **** 		// –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –ª–æ–∫–∞–ª–∏
 260:LCDMelt.h     **** 		char isAvaibleSymb = false;
 261:LCDMelt.h     **** 		for (int j = 0; j < SYMB_COUNT; j++) {
 262:LCDMelt.h     **** 			// –ï—Å–ª–∏ –≤ –ª–æ–∫–∞–ª–∏ –µ—Å—Ç—å –Ω–∞—à —Å–∏–º–≤–æ–ª –≤—ã–≤–æ–¥–∏–º –µ–≥–æ
 263:LCDMelt.h     **** 			if (local_ru[j] == str[i]) {
 264:LCDMelt.h     **** 				isAvaibleSymb = true;
 265:LCDMelt.h     **** 				WriteData(local_melt[j]);
 266:LCDMelt.h     **** 				break;
 267:LCDMelt.h     **** 			}
 268:LCDMelt.h     **** 		}
 269:LCDMelt.h     **** 		// –ï—Å–ª–∏ –≤ –ª–æ–∫–∞–ª–∏ –Ω–µ –±—ã–ª–æ —Å–∏–º–≤–æ–ª–∞ —Ç–æ –≤—ã–≤–æ–¥–∏–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω
 270:LCDMelt.h     **** 		if (isAvaibleSymb == false) {
 271:LCDMelt.h     **** 			WriteData(str[i]);
 272:LCDMelt.h     **** 		}
 273:LCDMelt.h     **** 	}
 274:LCDMelt.h     **** }
 275:LCDMelt.h     ****  */
 276:LCDMelt.h     **** 
 277:LCDMelt.h     **** // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫—É—Ä—Å–æ—Ä –≤–Ω–∞—á–∞–ª–æ —Å—Ç—Ä–æ–∫–∏
 278:LCDMelt.h     **** void LCDReturnHome() {
 1011               		.loc 6 278 0
 1012               		.cfi_startproc
 1013               	/* prologue: function */
 1014               	/* frame size = 0 */
 1015               	/* stack size = 0 */
 1016               	.L__stack_usage = 0
 279:LCDMelt.h     **** 	WriteCmd(0b00000011);
 1017               		.loc 6 279 0
 1018 0306 83E0      		ldi r24,lo8(3)
 1019 0308 00D0      		rcall WriteCmd
 1020               	.LVL74:
 1021               	.LBB88:
 1022               	.LBB89:
 163:/usr/lib/avr/include/util/delay.h **** 
 1023               		.loc 5 163 0
 1024 030a 8FE9      		ldi r24,lo8(3999)
 1025 030c 9FE0      		ldi r25,hi8(3999)
 1026 030e 0197      		1: sbiw r24,1
 1027 0310 01F4      		brne 1b
 1028 0312 00C0      		rjmp .
 1029 0314 0000      		nop
 1030 0316 0895      		ret
 1031               	.LBE89:
 1032               	.LBE88:
 1033               		.cfi_endproc
 1034               	.LFE29:
 1036               	.global	LCDClearCurrLine
 1038               	LCDClearCurrLine:
 1039               	.LFB30:
 280:LCDMelt.h     **** 	_delay_ms(1);
 281:LCDMelt.h     **** }
 282:LCDMelt.h     **** 
 283:LCDMelt.h     **** // –û—á–∏—â–∞–µ–º —Å—Ç—Ä–æ–∫—É
 284:LCDMelt.h     **** void LCDClearCurrLine() {
 1040               		.loc 6 284 0
 1041               		.cfi_startproc
 1042 0318 CF93      		push r28
 1043               	.LCFI7:
 1044               		.cfi_def_cfa_offset 3
 1045               		.cfi_offset 28, -2
 1046 031a DF93      		push r29
 1047               	.LCFI8:
 1048               		.cfi_def_cfa_offset 4
 1049               		.cfi_offset 29, -3
 1050               	/* prologue: function */
 1051               	/* frame size = 0 */
 1052               	/* stack size = 2 */
 1053               	.L__stack_usage = 2
 1054               	.LVL75:
 1055               		.loc 6 284 0
 1056 031c C0E1      		ldi r28,lo8(16)
 1057 031e D0E0      		ldi r29,0
 1058               	.LVL76:
 1059               	.L87:
 1060               	.LBB90:
 285:LCDMelt.h     **** 
 286:LCDMelt.h     **** 	for (int i = 0; i < 16; i++) {
 287:LCDMelt.h     **** 		WriteData(' ');
 1061               		.loc 6 287 0 discriminator 2
 1062 0320 80E2      		ldi r24,lo8(32)
 1063 0322 00D0      		rcall WriteData
 1064               	.LVL77:
 1065 0324 2197      		sbiw r28,1
 1066               	.LVL78:
 286:LCDMelt.h     **** 		WriteData(' ');
 1067               		.loc 6 286 0 discriminator 2
 1068 0326 2097      		sbiw r28,0
 1069 0328 01F4      		brne .L87
 1070               	/* epilogue start */
 1071               	.LBE90:
 288:LCDMelt.h     **** 	}
 289:LCDMelt.h     **** }
 1072               		.loc 6 289 0
 1073 032a DF91      		pop r29
 1074 032c CF91      		pop r28
 1075               	.LVL79:
 1076 032e 0895      		ret
 1077               		.cfi_endproc
 1078               	.LFE30:
 1080               	.global	LCDCursorShift
 1082               	LCDCursorShift:
 1083               	.LFB31:
 290:LCDMelt.h     **** 
 291:LCDMelt.h     **** // –°–¥–≤–∏–Ω—É—Ç—å –∫—É—Ä—Å–æ—Ä –≤–ø—Ä–∞–≤–∞
 292:LCDMelt.h     **** void LCDCursorShift(int posShift) {
 1084               		.loc 6 292 0
 1085               		.cfi_startproc
 1086               	.LVL80:
 1087 0330 0F93      		push r16
 1088               	.LCFI9:
 1089               		.cfi_def_cfa_offset 3
 1090               		.cfi_offset 16, -2
 1091 0332 1F93      		push r17
 1092               	.LCFI10:
 1093               		.cfi_def_cfa_offset 4
 1094               		.cfi_offset 17, -3
 1095 0334 CF93      		push r28
 1096               	.LCFI11:
 1097               		.cfi_def_cfa_offset 5
 1098               		.cfi_offset 28, -4
 1099 0336 DF93      		push r29
 1100               	.LCFI12:
 1101               		.cfi_def_cfa_offset 6
 1102               		.cfi_offset 29, -5
 1103               	/* prologue: function */
 1104               	/* frame size = 0 */
 1105               	/* stack size = 4 */
 1106               	.L__stack_usage = 4
 1107 0338 8C01      		movw r16,r24
 1108               	.LVL81:
 1109               	.LBB91:
 293:LCDMelt.h     **** 
 294:LCDMelt.h     **** 	for (int i = 0; i < posShift; i++) {
 1110               		.loc 6 294 0
 1111 033a C0E0      		ldi r28,0
 1112 033c D0E0      		ldi r29,0
 1113               	.LVL82:
 1114               	.L89:
 1115               		.loc 6 294 0 is_stmt 0 discriminator 1
 1116 033e C017      		cp r28,r16
 1117 0340 D107      		cpc r29,r17
 1118 0342 04F4      		brge .L91
 295:LCDMelt.h     **** 		WriteCmd(0b00010100);
 1119               		.loc 6 295 0 is_stmt 1 discriminator 2
 1120 0344 84E1      		ldi r24,lo8(20)
 1121 0346 00D0      		rcall WriteCmd
 1122               	.LVL83:
 1123               	.LBB92:
 1124               	.LBB93:
 163:/usr/lib/avr/include/util/delay.h **** 
 1125               		.loc 5 163 0 discriminator 2
 1126 0348 8FE9      		ldi r24,lo8(3999)
 1127 034a 9FE0      		ldi r25,hi8(3999)
 1128 034c 0197      		1: sbiw r24,1
 1129 034e 01F4      		brne 1b
 1130 0350 00C0      		rjmp .
 1131 0352 0000      		nop
 1132               	.LBE93:
 1133               	.LBE92:
 294:LCDMelt.h     **** 		WriteCmd(0b00010100);
 1134               		.loc 6 294 0 discriminator 2
 1135 0354 2196      		adiw r28,1
 1136               	.LVL84:
 1137 0356 00C0      		rjmp .L89
 1138               	.LVL85:
 1139               	.L91:
 1140               	/* epilogue start */
 1141               	.LBE91:
 296:LCDMelt.h     **** 		_delay_ms(1);
 297:LCDMelt.h     **** 	}
 298:LCDMelt.h     **** }
 1142               		.loc 6 298 0
 1143 0358 DF91      		pop r29
 1144 035a CF91      		pop r28
 1145               	.LVL86:
 1146 035c 1F91      		pop r17
 1147 035e 0F91      		pop r16
 1148               	.LVL87:
 1149 0360 0895      		ret
 1150               		.cfi_endproc
 1151               	.LFE31:
 1153               		.section	.rodata.str1.1,"aMS",@progbits,1
 1154               	.LC0:
 1155 0000 9000      		.string	"\220"
 1156               	.LC1:
 1157 0002 2000      		.string	" "
 1158               		.text
 1159               	.global	printMenuEx
 1161               	printMenuEx:
 1162               	.LFB36:
 1163               		.file 7 "menu.h"
   1:menu.h        **** /*
   2:menu.h        ****  * menu.h
   3:menu.h        ****  *
   4:menu.h        ****  *  Created on: 06.10.2015
   5:menu.h        ****  *      Author: anton
   6:menu.h        ****  */
   7:menu.h        **** 
   8:menu.h        **** #ifndef MENU_H_
   9:menu.h        **** #define MENU_H_
  10:menu.h        **** 
  11:menu.h        **** #include <avr/io.h>
  12:menu.h        **** #include <util/delay.h>
  13:menu.h        **** #include "sysfunc.h"
  14:menu.h        **** 
  15:menu.h        **** #define MENUSTATE_MAIN 0
  16:menu.h        **** char menustate = MENUSTATE_MAIN;
  17:menu.h        **** char main_menu_index = 0;
  18:menu.h        **** char menu_duration = 0;
  19:menu.h        **** 
  20:menu.h        **** #define MENU_ITEMS_COUNT 7
  21:menu.h        **** char main_menu[][MAX_LCD_LINE] = { /* –ò–º–ø—É–ª—å—Å */
  22:menu.h        **** "\xC8\xEC\xEF\xF3\xEB\xFC\xF1",
  23:menu.h        **** /* –ü–∞—É–∑–∞ */
  24:menu.h        **** "\xCF\xE0\xF3\xE7\xE0",
  25:menu.h        **** /* –ß–∏—Å–ª–æ –∏–º–ø—É–ª—å—Å–æ–≤ */
  26:menu.h        **** "\xD7\xE8\xF1\xEB\xEE \xE8\xEC\xEF\xF3\xEB\xFC\xF1\xEE\xE2",
  27:menu.h        **** /* –°–≤—è–∑—å —Å –ü–ö */
  28:menu.h        **** "\xD1\xE2\xFF\xE7\xFC \xF1 \xCF\xCA",
  29:menu.h        **** /* –†–µ–∂–∏–º */
  30:menu.h        **** "\xD0\xE5\xE6\xE8\xEC",
  31:menu.h        **** /* –ó–∞–ø—É—Å–∫ */
  32:menu.h        **** "\xC7\xE0\xEF\xF3\xF1\xEA",
  33:menu.h        **** /*–û —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ*/
  34:menu.h        **** "\xCE \xF3\xF1\xF2\xF0\xEE\xE9\xF1\xF2\xE2\xE5" };
  35:menu.h        **** 
  36:menu.h        **** void printMenuEx(char text[][MAX_LCD_LINE], int index, int count) {
 1164               		.loc 7 36 0
 1165               		.cfi_startproc
 1166               	.LVL88:
 1167 0362 CF92      		push r12
 1168               	.LCFI13:
 1169               		.cfi_def_cfa_offset 3
 1170               		.cfi_offset 12, -2
 1171 0364 DF92      		push r13
 1172               	.LCFI14:
 1173               		.cfi_def_cfa_offset 4
 1174               		.cfi_offset 13, -3
 1175 0366 EF92      		push r14
 1176               	.LCFI15:
 1177               		.cfi_def_cfa_offset 5
 1178               		.cfi_offset 14, -4
 1179 0368 FF92      		push r15
 1180               	.LCFI16:
 1181               		.cfi_def_cfa_offset 6
 1182               		.cfi_offset 15, -5
 1183 036a 0F93      		push r16
 1184               	.LCFI17:
 1185               		.cfi_def_cfa_offset 7
 1186               		.cfi_offset 16, -6
 1187 036c 1F93      		push r17
 1188               	.LCFI18:
 1189               		.cfi_def_cfa_offset 8
 1190               		.cfi_offset 17, -7
 1191 036e CF93      		push r28
 1192               	.LCFI19:
 1193               		.cfi_def_cfa_offset 9
 1194               		.cfi_offset 28, -8
 1195 0370 DF93      		push r29
 1196               	.LCFI20:
 1197               		.cfi_def_cfa_offset 10
 1198               		.cfi_offset 29, -9
 1199               	/* prologue: function */
 1200               	/* frame size = 0 */
 1201               	/* stack size = 8 */
 1202               	.L__stack_usage = 8
 1203 0372 EC01      		movw r28,r24
 1204 0374 8B01      		movw r16,r22
 1205 0376 6A01      		movw r12,r20
  37:menu.h        **** 	LCDClrScr();
 1206               		.loc 7 37 0
 1207 0378 00D0      		rcall LCDClrScr
 1208               	.LVL89:
  38:menu.h        **** 	LCDFirstLine();
 1209               		.loc 7 38 0
 1210 037a 00D0      		rcall LCDFirstLine
 1211               	.LVL90:
  39:menu.h        **** 	// —Å—Ç—Ä–µ–ª–∫–∞ —Å–≤–µ—Ä—Ö—É
  40:menu.h        **** 	if (menu_duration == 0) {
 1212               		.loc 7 40 0
 1213 037c 8091 0000 		lds r24,menu_duration
 1214 0380 8111      		cpse r24,__zero_reg__
 1215 0382 00C0      		rjmp .L93
 1216               	.LVL91:
 1217               	.LBB96:
 1218               	.LBB97:
  41:menu.h        ****         LCDPrint(SYMB_ARROW_RIGHT);
 1219               		.loc 7 41 0
 1220 0384 80E0      		ldi r24,lo8(.LC0)
 1221 0386 90E0      		ldi r25,hi8(.LC0)
 1222 0388 00D0      		rcall LCDPrint
 1223               	.LVL92:
  42:menu.h        **** 		LCDPrint(text[index]);
 1224               		.loc 7 42 0
 1225 038a 7801      		movw r14,r16
 1226 038c 94E0      		ldi r25,4
 1227               		1:
 1228 038e EE0C      		lsl r14
 1229 0390 FF1C      		rol r15
 1230 0392 9A95      		dec r25
 1231 0394 01F4      		brne 1b
 1232 0396 CE01      		movw r24,r28
 1233 0398 8E0D      		add r24,r14
 1234 039a 9F1D      		adc r25,r15
 1235 039c 00D0      		rcall LCDPrint
 1236               	.LVL93:
  43:menu.h        **** 		LCDLastLine();
 1237               		.loc 7 43 0
 1238 039e 00D0      		rcall LCDLastLine
 1239               	.LVL94:
  44:menu.h        ****         LCDPrint(SYMB_SPACE);
 1240               		.loc 7 44 0
 1241 03a0 80E0      		ldi r24,lo8(.LC1)
 1242 03a2 90E0      		ldi r25,hi8(.LC1)
 1243 03a4 00D0      		rcall LCDPrint
 1244               	.LVL95:
  45:menu.h        **** 		if ((index + 1) < count) {
 1245               		.loc 7 45 0
 1246 03a6 0F5F      		subi r16,-1
 1247 03a8 1F4F      		sbci r17,-1
 1248               	.LVL96:
 1249 03aa 0C15      		cp r16,r12
 1250 03ac 1D05      		cpc r17,r13
 1251 03ae 04F4      		brge .L92
  46:menu.h        **** 			LCDPrint(text[index + 1]);
 1252               		.loc 7 46 0
 1253 03b0 C701      		movw r24,r14
 1254 03b2 00C0      		rjmp .L95
 1255               	.LVL97:
 1256               	.L93:
 1257               	.LBE97:
 1258               	.LBE96:
  47:menu.h        **** 		}
  48:menu.h        **** 	} else {
  49:menu.h        **** 		// —Å—Ç—Ä–µ–ª–∫–∞ —Å–Ω–∏–∑—É
  50:menu.h        ****         LCDPrint(SYMB_SPACE);
 1259               		.loc 7 50 0
 1260 03b4 80E0      		ldi r24,lo8(.LC1)
 1261 03b6 90E0      		ldi r25,hi8(.LC1)
 1262 03b8 00D0      		rcall LCDPrint
 1263               	.LVL98:
  51:menu.h        **** 		LCDPrint(text[index - 1]);
 1264               		.loc 7 51 0
 1265 03ba 0150      		subi r16,1
 1266 03bc 104F      		sbci r17,-16
 1267               	.LVL99:
 1268 03be 84E0      		ldi r24,4
 1269               		1:
 1270 03c0 000F      		lsl r16
 1271 03c2 111F      		rol r17
 1272 03c4 8A95      		dec r24
 1273 03c6 01F4      		brne 1b
 1274               	.LVL100:
 1275 03c8 CE01      		movw r24,r28
 1276 03ca 800F      		add r24,r16
 1277 03cc 911F      		adc r25,r17
 1278 03ce 00D0      		rcall LCDPrint
 1279               	.LVL101:
  52:menu.h        **** 		LCDLastLine();
 1280               		.loc 7 52 0
 1281 03d0 00D0      		rcall LCDLastLine
 1282               	.LVL102:
  53:menu.h        ****         LCDPrint(SYMB_ARROW_RIGHT);
 1283               		.loc 7 53 0
 1284 03d2 80E0      		ldi r24,lo8(.LC0)
 1285 03d4 90E0      		ldi r25,hi8(.LC0)
 1286 03d6 00D0      		rcall LCDPrint
 1287               	.LVL103:
  54:menu.h        **** 		LCDPrint(text[index]);
 1288               		.loc 7 54 0
 1289 03d8 C801      		movw r24,r16
 1290               	.L95:
 1291 03da 4096      		adiw r24,16
 1292 03dc 8C0F      		add r24,r28
 1293 03de 9D1F      		adc r25,r29
 1294               	/* epilogue start */
  55:menu.h        **** 	}
  56:menu.h        **** }
 1295               		.loc 7 56 0
 1296 03e0 DF91      		pop r29
 1297 03e2 CF91      		pop r28
 1298               	.LVL104:
 1299 03e4 1F91      		pop r17
 1300 03e6 0F91      		pop r16
 1301 03e8 FF90      		pop r15
 1302 03ea EF90      		pop r14
 1303 03ec DF90      		pop r13
 1304 03ee CF90      		pop r12
 1305               	.LVL105:
  54:menu.h        **** 		LCDPrint(text[index]);
 1306               		.loc 7 54 0
 1307 03f0 00C0      		rjmp LCDPrint
 1308               	.LVL106:
 1309               	.L92:
 1310               	/* epilogue start */
 1311               		.loc 7 56 0
 1312 03f2 DF91      		pop r29
 1313 03f4 CF91      		pop r28
 1314               	.LVL107:
 1315 03f6 1F91      		pop r17
 1316 03f8 0F91      		pop r16
 1317 03fa FF90      		pop r15
 1318 03fc EF90      		pop r14
 1319 03fe DF90      		pop r13
 1320 0400 CF90      		pop r12
 1321               	.LVL108:
 1322 0402 0895      		ret
 1323               		.cfi_endproc
 1324               	.LFE36:
 1326               	.global	printMenu
 1328               	printMenu:
 1329               	.LFB37:
  57:menu.h        **** 
  58:menu.h        **** void printMenu(char text[][MAX_LCD_LINE], int index) {
 1330               		.loc 7 58 0
 1331               		.cfi_startproc
 1332               	.LVL109:
 1333               	/* prologue: function */
 1334               	/* frame size = 0 */
 1335               	/* stack size = 0 */
 1336               	.L__stack_usage = 0
  59:menu.h        **** 
  60:menu.h        **** 	printMenuEx(text, index, MENU_ITEMS_COUNT);
 1337               		.loc 7 60 0
 1338 0404 47E0      		ldi r20,lo8(7)
 1339 0406 50E0      		ldi r21,0
 1340 0408 00C0      		rjmp printMenuEx
 1341               	.LVL110:
 1342               		.cfi_endproc
 1343               	.LFE37:
 1345               	.global	ReadButtonFromPORTB
 1347               	ReadButtonFromPORTB:
 1348               	.LFB38:
 1349               		.file 8 "Keyboard.h"
   1:Keyboard.h    **** /*
   2:Keyboard.h    ****  * Keyboard.h
   3:Keyboard.h    ****  *
   4:Keyboard.h    ****  *  Created on: 04.10.2015
   5:Keyboard.h    ****  *      Author: anton
   6:Keyboard.h    ****  */
   7:Keyboard.h    **** 
   8:Keyboard.h    **** #ifndef KEYBOARD_H_
   9:Keyboard.h    **** #define KEYBOARD_H_
  10:Keyboard.h    **** 
  11:Keyboard.h    **** #ifndef F_CPU
  12:Keyboard.h    **** #define F_CPU 8000000UL
  13:Keyboard.h    **** #endif
  14:Keyboard.h    **** 
  15:Keyboard.h    **** #include <avr/io.h>
  16:Keyboard.h    **** #include <util/delay.h>
  17:Keyboard.h    **** 
  18:Keyboard.h    **** // –ù–∞ –ø–æ—Ä—Ç—É –°
  19:Keyboard.h    **** #define BTN_PIN_LEFT 0
  20:Keyboard.h    **** #define BTN_PIN_SELECT 1
  21:Keyboard.h    **** #define BTN_PIN_RIGHT 2
  22:Keyboard.h    **** #define BTN_PIN_BOTTOM 3
  23:Keyboard.h    **** 
  24:Keyboard.h    **** // –ù–∞ –ø–æ—Ä—Ç—É B
  25:Keyboard.h    **** #define BTN_PIN_TOP 2
  26:Keyboard.h    **** 
  27:Keyboard.h    **** 
  28:Keyboard.h    **** int ReadButtonFromPORTB(int PinBtn) {
 1350               		.loc 8 28 0
 1351               		.cfi_startproc
 1352               	.LVL111:
 1353               	/* prologue: function */
 1354               	/* frame size = 0 */
 1355               	/* stack size = 0 */
 1356               	.L__stack_usage = 0
  29:Keyboard.h    **** // –ï—Å–ª–∏ –∫–Ω–æ–ø–∫–∞ –Ω–∞–∂–∞—Ç–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 1
  30:Keyboard.h    **** 	int result = 0;
  31:Keyboard.h    **** 	if (PINB & (1 << PinBtn)) { // –ë–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –∑–∞–º–µ—Ä
 1357               		.loc 8 31 0
 1358 040a 26B3      		in r18,0x16
 1359 040c 30E0      		ldi r19,0
 1360 040e 082E      		mov r0,r24
 1361 0410 00C0      		rjmp 2f
 1362               		1:
 1363 0412 3595      		asr r19
 1364 0414 2795      		ror r18
 1365               		2:
 1366 0416 0A94      		dec r0
 1367 0418 02F4      		brpl 1b
 1368 041a 20FD      		sbrc r18,0
 1369 041c 00C0      		rjmp .L98
 1370               	.L100:
  30:Keyboard.h    **** 	if (PINB & (1 << PinBtn)) { // –ë–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –∑–∞–º–µ—Ä
 1371               		.loc 8 30 0
 1372 041e 80E0      		ldi r24,0
 1373 0420 90E0      		ldi r25,0
 1374               	.LVL112:
 1375 0422 0895      		ret
 1376               	.LVL113:
 1377               	.L98:
 1378               	.LBB98:
 1379               	.LBB99:
 163:/usr/lib/avr/include/util/delay.h **** 
 1380               		.loc 5 163 0
 1381 0424 2FEF      		ldi r18,lo8(63999)
 1382 0426 39EF      		ldi r19,hi8(63999)
 1383 0428 90E0      		ldi r25,hlo8(63999)
 1384 042a 2150      		1: subi r18,1
 1385 042c 3040      		sbci r19,0
 1386 042e 9040      		sbci r25,0
 1387 0430 01F4      		brne 1b
 1388 0432 00C0      		rjmp .
 1389 0434 0000      		nop
 1390               	.LBE99:
 1391               	.LBE98:
  32:Keyboard.h    **** 		_delay_ms(20); // –∂–¥—ë–º 0.020 —Å–µ–∫
  33:Keyboard.h    **** 		if (PINB & (1 << PinBtn)) { // –î–µ–ª–∞–µ–º –≤—Ç–æ—Ä–æ–π –∑–∞–º–µ—Ä
 1392               		.loc 8 33 0
 1393 0436 26B3      		in r18,0x16
 1394 0438 30E0      		ldi r19,0
 1395 043a 082E      		mov r0,r24
 1396 043c 00C0      		rjmp 2f
 1397               		1:
 1398 043e 3595      		asr r19
 1399 0440 2795      		ror r18
 1400               		2:
 1401 0442 0A94      		dec r0
 1402 0444 02F4      		brpl 1b
 1403 0446 20FF      		sbrs r18,0
 1404 0448 00C0      		rjmp .L100
 1405 044a 21E0      		ldi r18,lo8(1)
 1406 044c 30E0      		ldi r19,0
 1407 044e 00C0      		rjmp 2f
 1408               		1:
 1409 0450 220F      		lsl r18
 1410 0452 331F      		rol r19
 1411               		2:
 1412 0454 8A95      		dec r24
 1413 0456 02F4      		brpl 1b
 1414               	.LVL114:
 1415               	.L101:
  34:Keyboard.h    **** // –ï—Å–ª–∏ –æ–Ω–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç, —Ç–æ –∫–Ω–æ–ø–∫–∞ –Ω–∞–∂–∞—Ç–∞
  35:Keyboard.h    **** 			result = 1;
  36:Keyboard.h    **** // –û–¥–Ω–∞–∫–æ –º—ã –±—É–¥–µ–º –∂–¥–∞—Ç—å –ø–æ–∫–∞ —é–∑–µ—Ä –Ω–µ –æ—Ç–ø—É—Å—Ç–∏—Ç –∫–Ω–æ–ø–∫—É
  37:Keyboard.h    **** 			while (PINB & (1 << PinBtn)) {
 1416               		.loc 8 37 0
 1417 0458 86B3      		in r24,0x16
 1418 045a 90E0      		ldi r25,0
 1419 045c 8223      		and r24,r18
 1420 045e 9323      		and r25,r19
 1421 0460 892B      		or r24,r25
 1422 0462 01F4      		brne .L101
  35:Keyboard.h    **** // –û–¥–Ω–∞–∫–æ –º—ã –±—É–¥–µ–º –∂–¥–∞—Ç—å –ø–æ–∫–∞ —é–∑–µ—Ä –Ω–µ –æ—Ç–ø—É—Å—Ç–∏—Ç –∫–Ω–æ–ø–∫—É
 1423               		.loc 8 35 0
 1424 0464 81E0      		ldi r24,lo8(1)
 1425 0466 90E0      		ldi r25,0
 1426               	.LVL115:
  38:Keyboard.h    **** // –ê –Ω–∞–¥–æ —ç—Ç–æ —á—Ç–æ –±—ã –ø–æ–≤—Ç–æ—Ä–Ω–æ –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–ª–æ —Å–æ–±—ã—Ç–∏–µ –Ω–∞–
  39:Keyboard.h    **** 			}
  40:Keyboard.h    **** 		}
  41:Keyboard.h    **** 	}
  42:Keyboard.h    **** 	return result;
  43:Keyboard.h    **** }
 1427               		.loc 8 43 0
 1428 0468 0895      		ret
 1429               		.cfi_endproc
 1430               	.LFE38:
 1432               	.global	ReadButtonFromPORTC
 1434               	ReadButtonFromPORTC:
 1435               	.LFB39:
  44:Keyboard.h    **** 
  45:Keyboard.h    **** int ReadButtonFromPORTC(int PinBtn) {
 1436               		.loc 8 45 0
 1437               		.cfi_startproc
 1438               	.LVL116:
 1439               	/* prologue: function */
 1440               	/* frame size = 0 */
 1441               	/* stack size = 0 */
 1442               	.L__stack_usage = 0
  46:Keyboard.h    **** // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–π
  47:Keyboard.h    **** 	int result = 0;
  48:Keyboard.h    **** 	if (PINC & (1 << PinBtn)) {
 1443               		.loc 8 48 0
 1444 046a 23B3      		in r18,0x13
 1445 046c 30E0      		ldi r19,0
 1446 046e 082E      		mov r0,r24
 1447 0470 00C0      		rjmp 2f
 1448               		1:
 1449 0472 3595      		asr r19
 1450 0474 2795      		ror r18
 1451               		2:
 1452 0476 0A94      		dec r0
 1453 0478 02F4      		brpl 1b
 1454 047a 20FD      		sbrc r18,0
 1455 047c 00C0      		rjmp .L107
 1456               	.L109:
  47:Keyboard.h    **** 	if (PINC & (1 << PinBtn)) {
 1457               		.loc 8 47 0
 1458 047e 80E0      		ldi r24,0
 1459 0480 90E0      		ldi r25,0
 1460               	.LVL117:
 1461 0482 0895      		ret
 1462               	.LVL118:
 1463               	.L107:
 1464               	.LBB106:
 1465               	.LBB107:
 163:/usr/lib/avr/include/util/delay.h **** 
 1466               		.loc 5 163 0
 1467 0484 2FEF      		ldi r18,lo8(63999)
 1468 0486 39EF      		ldi r19,hi8(63999)
 1469 0488 90E0      		ldi r25,hlo8(63999)
 1470 048a 2150      		1: subi r18,1
 1471 048c 3040      		sbci r19,0
 1472 048e 9040      		sbci r25,0
 1473 0490 01F4      		brne 1b
 1474 0492 00C0      		rjmp .
 1475 0494 0000      		nop
 1476               	.LBE107:
 1477               	.LBE106:
  49:Keyboard.h    **** 		_delay_ms(20);
  50:Keyboard.h    **** 		if (PINC & (1 << PinBtn)) {
 1478               		.loc 8 50 0
 1479 0496 23B3      		in r18,0x13
 1480 0498 30E0      		ldi r19,0
 1481 049a 082E      		mov r0,r24
 1482 049c 00C0      		rjmp 2f
 1483               		1:
 1484 049e 3595      		asr r19
 1485 04a0 2795      		ror r18
 1486               		2:
 1487 04a2 0A94      		dec r0
 1488 04a4 02F4      		brpl 1b
 1489 04a6 20FF      		sbrs r18,0
 1490 04a8 00C0      		rjmp .L109
 1491 04aa 21E0      		ldi r18,lo8(1)
 1492 04ac 30E0      		ldi r19,0
 1493 04ae 00C0      		rjmp 2f
 1494               		1:
 1495 04b0 220F      		lsl r18
 1496 04b2 331F      		rol r19
 1497               		2:
 1498 04b4 8A95      		dec r24
 1499 04b6 02F4      		brpl 1b
 1500               	.LVL119:
 1501               	.L110:
 1502               	.LBB108:
 1503               	.LBB109:
  51:Keyboard.h    **** 			result = 1;
  52:Keyboard.h    **** 			while (PINC & (1 << PinBtn)) {
 1504               		.loc 8 52 0
 1505 04b8 83B3      		in r24,0x13
 1506 04ba 90E0      		ldi r25,0
 1507 04bc 8223      		and r24,r18
 1508 04be 9323      		and r25,r19
 1509 04c0 892B      		or r24,r25
 1510 04c2 01F4      		brne .L110
 1511 04c4 81E0      		ldi r24,lo8(1)
 1512 04c6 90E0      		ldi r25,0
 1513               	.LVL120:
 1514               	.LBE109:
 1515               	.LBE108:
  53:Keyboard.h    **** 			}
  54:Keyboard.h    **** 		}
  55:Keyboard.h    **** 	}
  56:Keyboard.h    **** 	return result;
  57:Keyboard.h    **** }
 1516               		.loc 8 57 0
 1517 04c8 0895      		ret
 1518               		.cfi_endproc
 1519               	.LFE39:
 1521               	.global	ReadBtnTop
 1523               	ReadBtnTop:
 1524               	.LFB40:
  58:Keyboard.h    **** 
  59:Keyboard.h    **** // –ß–∏—Ç–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –≤–≤–µ—Ä—Ö
  60:Keyboard.h    **** int ReadBtnTop() {
 1525               		.loc 8 60 0
 1526               		.cfi_startproc
 1527               	/* prologue: function */
 1528               	/* frame size = 0 */
 1529               	/* stack size = 0 */
 1530               	.L__stack_usage = 0
  61:Keyboard.h    **** 	return ReadButtonFromPORTB(BTN_PIN_TOP);
 1531               		.loc 8 61 0
 1532 04ca 82E0      		ldi r24,lo8(2)
 1533 04cc 90E0      		ldi r25,0
 1534 04ce 00C0      		rjmp ReadButtonFromPORTB
 1535               	.LVL121:
 1536               		.cfi_endproc
 1537               	.LFE40:
 1539               	.global	ReadBtnLeft
 1541               	ReadBtnLeft:
 1542               	.LFB41:
  62:Keyboard.h    **** }
  63:Keyboard.h    **** 
  64:Keyboard.h    **** // –ß–∏—Ç–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ —Å–ª–µ–≤–∞
  65:Keyboard.h    **** int ReadBtnLeft() {
 1543               		.loc 8 65 0
 1544               		.cfi_startproc
 1545               	/* prologue: function */
 1546               	/* frame size = 0 */
 1547               	/* stack size = 0 */
 1548               	.L__stack_usage = 0
  66:Keyboard.h    **** 	return ReadButtonFromPORTC(BTN_PIN_LEFT);
 1549               		.loc 8 66 0
 1550 04d0 80E0      		ldi r24,0
 1551 04d2 90E0      		ldi r25,0
 1552 04d4 00C0      		rjmp ReadButtonFromPORTC
 1553               	.LVL122:
 1554               		.cfi_endproc
 1555               	.LFE41:
 1557               	.global	ReadBtnBottom
 1559               	ReadBtnBottom:
 1560               	.LFB42:
  67:Keyboard.h    **** }
  68:Keyboard.h    **** 
  69:Keyboard.h    **** // –ß–∏—Ç–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –≤–Ω–∏–∑
  70:Keyboard.h    **** int ReadBtnBottom() {
 1561               		.loc 8 70 0
 1562               		.cfi_startproc
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 0 */
 1566               	.L__stack_usage = 0
  71:Keyboard.h    **** 	return ReadButtonFromPORTC(BTN_PIN_BOTTOM);
 1567               		.loc 8 71 0
 1568 04d6 83E0      		ldi r24,lo8(3)
 1569 04d8 90E0      		ldi r25,0
 1570 04da 00C0      		rjmp ReadButtonFromPORTC
 1571               	.LVL123:
 1572               		.cfi_endproc
 1573               	.LFE42:
 1575               	.global	ReadBtnRight
 1577               	ReadBtnRight:
 1578               	.LFB43:
  72:Keyboard.h    **** }
  73:Keyboard.h    **** 
  74:Keyboard.h    **** // –ß–∏—Ç–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –≤–ø—Ä–∞–≤–æ
  75:Keyboard.h    **** int ReadBtnRight() {
 1579               		.loc 8 75 0
 1580               		.cfi_startproc
 1581               	/* prologue: function */
 1582               	/* frame size = 0 */
 1583               	/* stack size = 0 */
 1584               	.L__stack_usage = 0
  76:Keyboard.h    **** 	return ReadButtonFromPORTC(BTN_PIN_RIGHT);
 1585               		.loc 8 76 0
 1586 04dc 82E0      		ldi r24,lo8(2)
 1587 04de 90E0      		ldi r25,0
 1588 04e0 00C0      		rjmp ReadButtonFromPORTC
 1589               	.LVL124:
 1590               		.cfi_endproc
 1591               	.LFE43:
 1593               	.global	ReadBtnSelect
 1595               	ReadBtnSelect:
 1596               	.LFB44:
  77:Keyboard.h    **** }
  78:Keyboard.h    **** 
  79:Keyboard.h    **** // –ß–∏—Ç–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –≤—ã–±—Ä–∞—Ç—å
  80:Keyboard.h    **** int ReadBtnSelect() {
 1597               		.loc 8 80 0
 1598               		.cfi_startproc
 1599               	/* prologue: function */
 1600               	/* frame size = 0 */
 1601               	/* stack size = 0 */
 1602               	.L__stack_usage = 0
  81:Keyboard.h    **** 	return ReadButtonFromPORTC(BTN_PIN_SELECT);
 1603               		.loc 8 81 0
 1604 04e2 81E0      		ldi r24,lo8(1)
 1605 04e4 90E0      		ldi r25,0
 1606 04e6 00C0      		rjmp ReadButtonFromPORTC
 1607               	.LVL125:
 1608               		.cfi_endproc
 1609               	.LFE44:
 1611               	.global	selectFromList
 1613               	selectFromList:
 1614               	.LFB45:
 1615               		.file 9 "dialogs.h"
   1:dialogs.h     **** /*
   2:dialogs.h     ****  * dialogs.h
   3:dialogs.h     ****  *
   4:dialogs.h     ****  *  Created on: 09.10.2015
   5:dialogs.h     ****  *      Author: anton
   6:dialogs.h     ****  */
   7:dialogs.h     **** 
   8:dialogs.h     **** #ifndef DIALOGS_H_
   9:dialogs.h     **** #define DIALOGS_H_
  10:dialogs.h     **** 
  11:dialogs.h     **** #include <stdlib.h>
  12:dialogs.h     **** #include "menu.h"
  13:dialogs.h     **** #include "LCDMelt.h"
  14:dialogs.h     **** #include "Keyboard.h"
  15:dialogs.h     **** 
  16:dialogs.h     **** #define cursorUnderNum 0
  17:dialogs.h     **** #define cursorUnderOk 1
  18:dialogs.h     **** #define cursorUnderCancel 2
  19:dialogs.h     **** 
  20:dialogs.h     **** #define TEXT_OK "[\xCE\xEA]"
  21:dialogs.h     **** #define TEXT_CANCEL "[\xCE\xF2\xEC\xE5\xED\xE0]"
  22:dialogs.h     **** 
  23:dialogs.h     **** #define ARROW_RIGHT "\x90"
  24:dialogs.h     **** #define ARROW_LEFT "\x91"
  25:dialogs.h     **** #define ARROW_BOTTOM "\x92"
  26:dialogs.h     **** #define ARROW_TOP "\x93"
  27:dialogs.h     **** #define SYMB_SPACE "\x20"
  28:dialogs.h     **** 
  29:dialogs.h     **** /**
  30:dialogs.h     ****  * @brief selectFromList - –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–±—Ä–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞
  31:dialogs.h     ****  * @param blist - —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫
  32:dialogs.h     ****  * @param count - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –≤ —Å–ø–∏—Å–∫–µ
  33:dialogs.h     ****  * @return - –∏–Ω–¥–µ–∫—Å –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
  34:dialogs.h     ****  */
  35:dialogs.h     **** int selectFromList(char blist[][MAX_LCD_LINE], int count) {
 1616               		.loc 9 35 0
 1617               		.cfi_startproc
 1618               	.LVL126:
 1619 04e8 AF92      		push r10
 1620               	.LCFI21:
 1621               		.cfi_def_cfa_offset 3
 1622               		.cfi_offset 10, -2
 1623 04ea BF92      		push r11
 1624               	.LCFI22:
 1625               		.cfi_def_cfa_offset 4
 1626               		.cfi_offset 11, -3
 1627 04ec CF92      		push r12
 1628               	.LCFI23:
 1629               		.cfi_def_cfa_offset 5
 1630               		.cfi_offset 12, -4
 1631 04ee DF92      		push r13
 1632               	.LCFI24:
 1633               		.cfi_def_cfa_offset 6
 1634               		.cfi_offset 13, -5
 1635 04f0 EF92      		push r14
 1636               	.LCFI25:
 1637               		.cfi_def_cfa_offset 7
 1638               		.cfi_offset 14, -6
 1639 04f2 FF92      		push r15
 1640               	.LCFI26:
 1641               		.cfi_def_cfa_offset 8
 1642               		.cfi_offset 15, -7
 1643 04f4 0F93      		push r16
 1644               	.LCFI27:
 1645               		.cfi_def_cfa_offset 9
 1646               		.cfi_offset 16, -8
 1647 04f6 1F93      		push r17
 1648               	.LCFI28:
 1649               		.cfi_def_cfa_offset 10
 1650               		.cfi_offset 17, -9
 1651 04f8 CF93      		push r28
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 11
 1654               		.cfi_offset 28, -10
 1655 04fa DF93      		push r29
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 12
 1658               		.cfi_offset 29, -11
 1659               	/* prologue: function */
 1660               	/* frame size = 0 */
 1661               	/* stack size = 10 */
 1662               	.L__stack_usage = 10
 1663 04fc 7C01      		movw r14,r24
 1664 04fe 8B01      		movw r16,r22
  36:dialogs.h     **** 	LCDClrScr();
 1665               		.loc 9 36 0
 1666 0500 00D0      		rcall LCDClrScr
 1667               	.LVL127:
  37:dialogs.h     **** 	LCDFirstLine();
 1668               		.loc 9 37 0
 1669 0502 00D0      		rcall LCDFirstLine
 1670               	.LVL128:
  38:dialogs.h     ****     LCDReturnHome();
 1671               		.loc 9 38 0
 1672 0504 00D0      		rcall LCDReturnHome
 1673               	.LVL129:
  39:dialogs.h     **** 
  40:dialogs.h     **** 	// –ü–µ—á–∞—Ç–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
  41:dialogs.h     **** 	boolean CanUpdate = true;
  42:dialogs.h     ****     int list_index = 0;
  43:dialogs.h     ****     int old_menu_duration = menu_duration;
 1674               		.loc 9 43 0
 1675 0506 A090 0000 		lds r10,menu_duration
 1676               	.LVL130:
  44:dialogs.h     ****     menu_duration = 0;
 1677               		.loc 9 44 0
 1678 050a 1092 0000 		sts menu_duration,__zero_reg__
  42:dialogs.h     ****     int old_menu_duration = menu_duration;
 1679               		.loc 9 42 0
 1680 050e C0E0      		ldi r28,0
 1681 0510 D0E0      		ldi r29,0
  41:dialogs.h     ****     int list_index = 0;
 1682               		.loc 9 41 0
 1683 0512 BB24      		clr r11
 1684 0514 B394      		inc r11
  45:dialogs.h     **** 
  46:dialogs.h     **** 	while (1) {
  47:dialogs.h     **** 
  48:dialogs.h     **** 		if (CanUpdate) {            
  49:dialogs.h     **** 			printMenuEx(blist, list_index, count);
  50:dialogs.h     **** 			CanUpdate = false;
  51:dialogs.h     **** 		}
  52:dialogs.h     **** 
  53:dialogs.h     **** 		// –ù–∞–∂–∞—Ç–∞ –ª–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞
  54:dialogs.h     ****         if (ReadBtnTop()) {
  55:dialogs.h     **** 			if (list_index > 0) {
  56:dialogs.h     **** 				list_index -= 1;
  57:dialogs.h     **** 				CanUpdate = true;
  58:dialogs.h     **** 			}
  59:dialogs.h     ****         }
  60:dialogs.h     **** 		// –ù–∞–∂–∞—Ç–∞ –ª–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –∫–æ—Ç–æ—Ä–∞—è –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É
  61:dialogs.h     ****         if (ReadBtnBottom()) {
  62:dialogs.h     **** 			if (list_index < (count - 1)) {
 1685               		.loc 9 62 0
 1686 0516 6801      		movw r12,r16
 1687 0518 81E0      		ldi r24,1
 1688 051a C81A      		sub r12,r24
 1689 051c D108      		sbc r13,__zero_reg__
 1690               	.LVL131:
 1691               	.L125:
  48:dialogs.h     **** 			printMenuEx(blist, list_index, count);
 1692               		.loc 9 48 0
 1693 051e BB20      		tst r11
 1694 0520 01F0      		breq .L121
  49:dialogs.h     **** 			CanUpdate = false;
 1695               		.loc 9 49 0
 1696 0522 A801      		movw r20,r16
 1697 0524 BE01      		movw r22,r28
 1698 0526 C701      		movw r24,r14
 1699 0528 00D0      		rcall printMenuEx
 1700               	.LVL132:
 1701               	.L121:
  54:dialogs.h     **** 			if (list_index > 0) {
 1702               		.loc 9 54 0
 1703 052a 00D0      		rcall ReadBtnTop
 1704               	.LVL133:
 1705 052c 892B      		or r24,r25
 1706 052e 01F0      		breq .L127
  55:dialogs.h     **** 				list_index -= 1;
 1707               		.loc 9 55 0
 1708 0530 1C16      		cp __zero_reg__,r28
 1709 0532 1D06      		cpc __zero_reg__,r29
 1710 0534 04F4      		brge .L127
  56:dialogs.h     **** 				CanUpdate = true;
 1711               		.loc 9 56 0
 1712 0536 2197      		sbiw r28,1
 1713               	.LVL134:
  57:dialogs.h     **** 			}
 1714               		.loc 9 57 0
 1715 0538 BB24      		clr r11
 1716 053a B394      		inc r11
 1717 053c 00C0      		rjmp .L122
 1718               	.LVL135:
 1719               	.L127:
 1720 053e B12C      		mov r11,__zero_reg__
 1721               	.LVL136:
 1722               	.L122:
  61:dialogs.h     **** 			if (list_index < (count - 1)) {
 1723               		.loc 9 61 0
 1724 0540 00D0      		rcall ReadBtnBottom
 1725               	.LVL137:
 1726 0542 892B      		or r24,r25
 1727 0544 01F0      		breq .L123
 1728               		.loc 9 62 0
 1729 0546 CC15      		cp r28,r12
 1730 0548 DD05      		cpc r29,r13
 1731 054a 04F4      		brge .L123
  63:dialogs.h     **** 				list_index += 1;
 1732               		.loc 9 63 0
 1733 054c 2196      		adiw r28,1
 1734               	.LVL138:
  64:dialogs.h     **** 				CanUpdate = true;
 1735               		.loc 9 64 0
 1736 054e BB24      		clr r11
 1737 0550 B394      		inc r11
 1738               	.LVL139:
 1739               	.L123:
  65:dialogs.h     **** 			}
  66:dialogs.h     **** 		}
  67:dialogs.h     **** 
  68:dialogs.h     **** 		// –ù–∞–∂–∞—Ç–∞ –ª—é–±–∞—è –ø—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞
  69:dialogs.h     ****         if (ReadBtnSelect()) {
 1740               		.loc 9 69 0
 1741 0552 00D0      		rcall ReadBtnSelect
 1742               	.LVL140:
 1743 0554 892B      		or r24,r25
 1744 0556 01F0      		breq .L125
  70:dialogs.h     **** 			break;
  71:dialogs.h     ****         }
  72:dialogs.h     **** 	}
  73:dialogs.h     ****     menu_duration = old_menu_duration;
 1745               		.loc 9 73 0
 1746 0558 A092 0000 		sts menu_duration,r10
  74:dialogs.h     **** 	return list_index;
  75:dialogs.h     **** }
 1747               		.loc 9 75 0
 1748 055c CE01      		movw r24,r28
 1749               	/* epilogue start */
 1750 055e DF91      		pop r29
 1751 0560 CF91      		pop r28
 1752               	.LVL141:
 1753 0562 1F91      		pop r17
 1754 0564 0F91      		pop r16
 1755               	.LVL142:
 1756 0566 FF90      		pop r15
 1757 0568 EF90      		pop r14
 1758               	.LVL143:
 1759 056a DF90      		pop r13
 1760 056c CF90      		pop r12
 1761               	.LVL144:
 1762 056e BF90      		pop r11
 1763 0570 AF90      		pop r10
 1764               	.LVL145:
 1765 0572 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE45:
 1769               		.section	.rodata.str1.1
 1770               	.LC2:
 1771 0004 5BCE EA5D 		.string	"[\316\352]   [\316\362\354\345\355\340]"
 1771      2020 205B 
 1771      CEF2 ECE5 
 1771      EDE0 5D00 
 1772               		.text
 1773               	.global	msgBox
 1775               	msgBox:
 1776               	.LFB46:
  76:dialogs.h     **** 
  77:dialogs.h     **** /**
  78:dialogs.h     ****  * @brief msgBox - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
  79:dialogs.h     ****  * @param text - —Ç–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞
  80:dialogs.h     ****  * @return - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
  81:dialogs.h     ****  */
  82:dialogs.h     **** int msgBox(char text[]) {
 1777               		.loc 9 82 0
 1778               		.cfi_startproc
 1779               	.LVL146:
 1780 0574 EF92      		push r14
 1781               	.LCFI31:
 1782               		.cfi_def_cfa_offset 3
 1783               		.cfi_offset 14, -2
 1784 0576 FF92      		push r15
 1785               	.LCFI32:
 1786               		.cfi_def_cfa_offset 4
 1787               		.cfi_offset 15, -3
 1788 0578 1F93      		push r17
 1789               	.LCFI33:
 1790               		.cfi_def_cfa_offset 5
 1791               		.cfi_offset 17, -4
 1792 057a CF93      		push r28
 1793               	.LCFI34:
 1794               		.cfi_def_cfa_offset 6
 1795               		.cfi_offset 28, -5
 1796 057c DF93      		push r29
 1797               	.LCFI35:
 1798               		.cfi_def_cfa_offset 7
 1799               		.cfi_offset 29, -6
 1800 057e 00D0      		rcall .
 1801               	.LCFI36:
 1802               		.cfi_def_cfa_offset 9
 1803 0580 CDB7      		in r28,__SP_L__
 1804 0582 DEB7      		in r29,__SP_H__
 1805               	.LCFI37:
 1806               		.cfi_def_cfa_register 28
 1807               	/* prologue: function */
 1808               	/* frame size = 2 */
 1809               	/* stack size = 7 */
 1810               	.L__stack_usage = 7
 1811               	.LVL147:
  83:dialogs.h     **** 
  84:dialogs.h     ****     char cursorState = cursorUnderOk;
  85:dialogs.h     **** 	LCDClrScr();
 1812               		.loc 9 85 0
 1813 0584 8983      		std Y+1,r24
 1814 0586 9A83      		std Y+2,r25
 1815 0588 00D0      		rcall LCDClrScr
 1816               	.LVL148:
  86:dialogs.h     **** 	// –ü–µ—á–∞—Ç–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
  87:dialogs.h     **** 	LCDFirstLine();
 1817               		.loc 9 87 0
 1818 058a 00D0      		rcall LCDFirstLine
 1819               	.LVL149:
  88:dialogs.h     **** 	LCDPrint(text);
 1820               		.loc 9 88 0
 1821 058c 8981      		ldd r24,Y+1
 1822 058e 9A81      		ldd r25,Y+2
 1823 0590 00D0      		rcall LCDPrint
 1824               	.LVL150:
  89:dialogs.h     **** 	// –í—ã–≤–æ–¥–∏–º –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–∞
  90:dialogs.h     **** 	LCDLastLine();
 1825               		.loc 9 90 0
 1826 0592 00D0      		rcall LCDLastLine
 1827               	.LVL151:
  91:dialogs.h     ****     LCDPrint(ARROW_RIGHT);
 1828               		.loc 9 91 0
 1829 0594 80E0      		ldi r24,lo8(.LC0)
 1830 0596 90E0      		ldi r25,hi8(.LC0)
 1831 0598 00D0      		rcall LCDPrint
 1832               	.LVL152:
  92:dialogs.h     ****     LCDPrint("[\xCE\xEA]   [\xCE\xF2\xEC\xE5\xED\xE0]"); // –û–∫ –û—Ç–º–µ–Ω–∞
 1833               		.loc 9 92 0
 1834 059a 80E0      		ldi r24,lo8(.LC2)
 1835 059c 90E0      		ldi r25,hi8(.LC2)
 1836 059e 00D0      		rcall LCDPrint
 1837               	.LVL153:
  84:dialogs.h     **** 	LCDClrScr();
 1838               		.loc 9 84 0
 1839 05a0 11E0      		ldi r17,lo8(1)
 1840               	.LVL154:
 1841               	.L138:
  93:dialogs.h     **** 	while (1) {
  94:dialogs.h     **** 		// –î–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä
  95:dialogs.h     ****         if (ReadBtnRight() | ReadBtnLeft()) {
 1842               		.loc 9 95 0
 1843 05a2 00D0      		rcall ReadBtnRight
 1844               	.LVL155:
 1845 05a4 7C01      		movw r14,r24
 1846 05a6 00D0      		rcall ReadBtnLeft
 1847               	.LVL156:
 1848 05a8 8E29      		or r24,r14
 1849 05aa 9F29      		or r25,r15
 1850 05ac 892B      		or r24,r25
 1851 05ae 01F0      		breq .L135
  96:dialogs.h     **** 			if (cursorState == cursorUnderOk) {
 1852               		.loc 9 96 0
 1853 05b0 1130      		cpi r17,lo8(1)
 1854 05b2 01F4      		brne .L136
  97:dialogs.h     **** 				LCDLastLine();
 1855               		.loc 9 97 0
 1856 05b4 00D0      		rcall LCDLastLine
 1857               	.LVL157:
  98:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 1858               		.loc 9 98 0
 1859 05b6 80E0      		ldi r24,lo8(.LC1)
 1860 05b8 90E0      		ldi r25,hi8(.LC1)
 1861 05ba 00D0      		rcall LCDPrint
 1862               	.LVL158:
  99:dialogs.h     **** 				cursorState = cursorUnderCancel;
 100:dialogs.h     **** 				LCDCursorShift(6);
 1863               		.loc 9 100 0
 1864 05bc 86E0      		ldi r24,lo8(6)
 1865 05be 90E0      		ldi r25,0
 1866 05c0 00D0      		rcall LCDCursorShift
 1867               	.LVL159:
 101:dialogs.h     ****                 LCDPrint(ARROW_RIGHT);
 1868               		.loc 9 101 0
 1869 05c2 80E0      		ldi r24,lo8(.LC0)
 1870 05c4 90E0      		ldi r25,hi8(.LC0)
 1871 05c6 00D0      		rcall LCDPrint
 1872               	.LVL160:
  99:dialogs.h     **** 				cursorState = cursorUnderCancel;
 1873               		.loc 9 99 0
 1874 05c8 12E0      		ldi r17,lo8(2)
 1875 05ca 00C0      		rjmp .L135
 1876               	.LVL161:
 1877               	.L136:
 102:dialogs.h     **** 			} else {
 103:dialogs.h     **** 				LCDLastLine();
 1878               		.loc 9 103 0
 1879 05cc 00D0      		rcall LCDLastLine
 1880               	.LVL162:
 104:dialogs.h     **** 				LCDCursorShift(7);
 1881               		.loc 9 104 0
 1882 05ce 87E0      		ldi r24,lo8(7)
 1883 05d0 90E0      		ldi r25,0
 1884 05d2 00D0      		rcall LCDCursorShift
 1885               	.LVL163:
 105:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 1886               		.loc 9 105 0
 1887 05d4 80E0      		ldi r24,lo8(.LC1)
 1888 05d6 90E0      		ldi r25,hi8(.LC1)
 1889 05d8 00D0      		rcall LCDPrint
 1890               	.LVL164:
 106:dialogs.h     **** 				cursorState = cursorUnderOk;
 107:dialogs.h     **** 				LCDLastLine();
 1891               		.loc 9 107 0
 1892 05da 00D0      		rcall LCDLastLine
 1893               	.LVL165:
 108:dialogs.h     ****                 LCDPrint(ARROW_RIGHT);
 1894               		.loc 9 108 0
 1895 05dc 80E0      		ldi r24,lo8(.LC0)
 1896 05de 90E0      		ldi r25,hi8(.LC0)
 1897 05e0 00D0      		rcall LCDPrint
 1898               	.LVL166:
 106:dialogs.h     **** 				cursorState = cursorUnderOk;
 1899               		.loc 9 106 0
 1900 05e2 11E0      		ldi r17,lo8(1)
 1901               	.LVL167:
 1902               	.L135:
 109:dialogs.h     **** 			}
 110:dialogs.h     **** 		}
 111:dialogs.h     **** 		// –î–µ–ª–∞–µ–º –≤—ã–±–æ—Ä
 112:dialogs.h     ****         if (ReadBtnSelect()) {
 1903               		.loc 9 112 0
 1904 05e4 00D0      		rcall ReadBtnSelect
 1905               	.LVL168:
 1906 05e6 892B      		or r24,r25
 1907 05e8 01F0      		breq .L138
 113:dialogs.h     **** 			if (cursorState == cursorUnderOk) {
 1908               		.loc 9 113 0
 1909 05ea 81E0      		ldi r24,lo8(1)
 1910 05ec 90E0      		ldi r25,0
 1911 05ee 1130      		cpi r17,lo8(1)
 1912 05f0 01F0      		breq .L139
 1913 05f2 80E0      		ldi r24,0
 1914 05f4 90E0      		ldi r25,0
 1915               	.L139:
 1916               	/* epilogue start */
 114:dialogs.h     **** 				return 1;
 115:dialogs.h     **** 			} else {
 116:dialogs.h     **** 				return 0;
 117:dialogs.h     **** 			}
 118:dialogs.h     ****         }
 119:dialogs.h     **** 
 120:dialogs.h     **** 	}
 121:dialogs.h     **** 	return 1;
 122:dialogs.h     **** 
 123:dialogs.h     **** }
 1917               		.loc 9 123 0
 1918 05f6 0F90      		pop __tmp_reg__
 1919 05f8 0F90      		pop __tmp_reg__
 1920 05fa DF91      		pop r29
 1921 05fc CF91      		pop r28
 1922 05fe 1F91      		pop r17
 1923               	.LVL169:
 1924 0600 FF90      		pop r15
 1925 0602 EF90      		pop r14
 1926 0604 0895      		ret
 1927               		.cfi_endproc
 1928               	.LFE46:
 1930               		.section	.rodata.str1.1
 1931               	.LC3:
 1932 0014 9300      		.string	"\223"
 1933               	.LC4:
 1934 0016 5BCE EA5D 		.string	"[\316\352]"
 1934      00
 1935               	.LC5:
 1936 001b 5BCE F2EC 		.string	"[\316\362\354\345\355\340]"
 1936      E5ED E05D 
 1936      00
 1937               		.text
 1938               	.global	getNumber
 1940               	getNumber:
 1941               	.LFB47:
 124:dialogs.h     **** 
 125:dialogs.h     **** /**
 126:dialogs.h     ****  * @brief getNumber - –§—É–Ω–∫—Ü–∏—è –≤—ã–≤–æ–¥–∏—Ç –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ —á–∏—Å–ª–∞
 127:dialogs.h     ****  * @param defaultNum - –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
 128:dialogs.h     ****  * @return - –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–
 129:dialogs.h     ****  */
 130:dialogs.h     **** int getNumber(int defaultNum) {
 1942               		.loc 9 130 0
 1943               		.cfi_startproc
 1944               	.LVL170:
 1945 0606 2F92      		push r2
 1946               	.LCFI38:
 1947               		.cfi_def_cfa_offset 3
 1948               		.cfi_offset 2, -2
 1949 0608 3F92      		push r3
 1950               	.LCFI39:
 1951               		.cfi_def_cfa_offset 4
 1952               		.cfi_offset 3, -3
 1953 060a 5F92      		push r5
 1954               	.LCFI40:
 1955               		.cfi_def_cfa_offset 5
 1956               		.cfi_offset 5, -4
 1957 060c 6F92      		push r6
 1958               	.LCFI41:
 1959               		.cfi_def_cfa_offset 6
 1960               		.cfi_offset 6, -5
 1961 060e 7F92      		push r7
 1962               	.LCFI42:
 1963               		.cfi_def_cfa_offset 7
 1964               		.cfi_offset 7, -6
 1965 0610 8F92      		push r8
 1966               	.LCFI43:
 1967               		.cfi_def_cfa_offset 8
 1968               		.cfi_offset 8, -7
 1969 0612 9F92      		push r9
 1970               	.LCFI44:
 1971               		.cfi_def_cfa_offset 9
 1972               		.cfi_offset 9, -8
 1973 0614 AF92      		push r10
 1974               	.LCFI45:
 1975               		.cfi_def_cfa_offset 10
 1976               		.cfi_offset 10, -9
 1977 0616 BF92      		push r11
 1978               	.LCFI46:
 1979               		.cfi_def_cfa_offset 11
 1980               		.cfi_offset 11, -10
 1981 0618 CF92      		push r12
 1982               	.LCFI47:
 1983               		.cfi_def_cfa_offset 12
 1984               		.cfi_offset 12, -11
 1985 061a DF92      		push r13
 1986               	.LCFI48:
 1987               		.cfi_def_cfa_offset 13
 1988               		.cfi_offset 13, -12
 1989 061c EF92      		push r14
 1990               	.LCFI49:
 1991               		.cfi_def_cfa_offset 14
 1992               		.cfi_offset 14, -13
 1993 061e FF92      		push r15
 1994               	.LCFI50:
 1995               		.cfi_def_cfa_offset 15
 1996               		.cfi_offset 15, -14
 1997 0620 0F93      		push r16
 1998               	.LCFI51:
 1999               		.cfi_def_cfa_offset 16
 2000               		.cfi_offset 16, -15
 2001 0622 1F93      		push r17
 2002               	.LCFI52:
 2003               		.cfi_def_cfa_offset 17
 2004               		.cfi_offset 17, -16
 2005 0624 CF93      		push r28
 2006               	.LCFI53:
 2007               		.cfi_def_cfa_offset 18
 2008               		.cfi_offset 28, -17
 2009 0626 DF93      		push r29
 2010               	.LCFI54:
 2011               		.cfi_def_cfa_offset 19
 2012               		.cfi_offset 29, -18
 2013 0628 CDB7      		in r28,__SP_L__
 2014 062a DEB7      		in r29,__SP_H__
 2015               	.LCFI55:
 2016               		.cfi_def_cfa_register 28
 2017 062c 2A97      		sbiw r28,10
 2018               	.LCFI56:
 2019               		.cfi_def_cfa_offset 29
 2020 062e 0FB6      		in __tmp_reg__,__SREG__
 2021 0630 F894      		cli
 2022 0632 DEBF      		out __SP_H__,r29
 2023 0634 0FBE      		out __SREG__,__tmp_reg__
 2024 0636 CDBF      		out __SP_L__,r28
 2025               	/* prologue: function */
 2026               	/* frame size = 10 */
 2027               	/* stack size = 27 */
 2028               	.L__stack_usage = 27
 2029 0638 582E      		mov r5,r24
 2030 063a 692E      		mov r6,r25
 2031               	.LVL171:
 131:dialogs.h     **** 
 132:dialogs.h     **** 	char buf[10];
 133:dialogs.h     **** 	char count = 0;
 134:dialogs.h     **** 	char pos = 0;
 135:dialogs.h     **** 	char cursorState = cursorUnderNum;
 136:dialogs.h     **** 	int workNum = defaultNum;
 137:dialogs.h     **** 
 138:dialogs.h     **** 	LCDClrScr();
 2032               		.loc 9 138 0
 2033 063c 00D0      		rcall LCDClrScr
 2034               	.LVL172:
 139:dialogs.h     **** 	LCDFirstLine();
 2035               		.loc 9 139 0
 2036 063e 00D0      		rcall LCDFirstLine
 2037               	.LVL173:
 2038               	.LBB110:
 2039               	.LBB111:
 2040               		.file 10 "/usr/lib/avr/include/stdlib.h"
   1:/usr/lib/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/lib/avr/include/stdlib.h **** 
   4:/usr/lib/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/lib/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/lib/avr/include/stdlib.h **** 
   7:/usr/lib/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/lib/avr/include/stdlib.h **** 
   9:/usr/lib/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/lib/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/lib/avr/include/stdlib.h **** 
  12:/usr/lib/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/lib/avr/include/stdlib.h **** 
  15:/usr/lib/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/lib/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/lib/avr/include/stdlib.h ****      distribution.
  19:/usr/lib/avr/include/stdlib.h **** 
  20:/usr/lib/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/lib/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/lib/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/lib/avr/include/stdlib.h **** 
  24:/usr/lib/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/lib/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/lib/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/lib/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/lib/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/lib/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/lib/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/lib/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/lib/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/lib/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/lib/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/lib/avr/include/stdlib.h **** 
  36:/usr/lib/avr/include/stdlib.h ****   $Id$
  37:/usr/lib/avr/include/stdlib.h **** */
  38:/usr/lib/avr/include/stdlib.h **** 
  39:/usr/lib/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/lib/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/lib/avr/include/stdlib.h **** 
  42:/usr/lib/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/lib/avr/include/stdlib.h **** 
  44:/usr/lib/avr/include/stdlib.h **** #define __need_NULL
  45:/usr/lib/avr/include/stdlib.h **** #define __need_size_t
  46:/usr/lib/avr/include/stdlib.h **** #define __need_wchar_t
  47:/usr/lib/avr/include/stdlib.h **** #include <stddef.h>
  48:/usr/lib/avr/include/stdlib.h **** 
  49:/usr/lib/avr/include/stdlib.h **** #ifndef __ptr_t
  50:/usr/lib/avr/include/stdlib.h **** #define __ptr_t void *
  51:/usr/lib/avr/include/stdlib.h **** #endif
  52:/usr/lib/avr/include/stdlib.h **** 
  53:/usr/lib/avr/include/stdlib.h **** #ifdef __cplusplus
  54:/usr/lib/avr/include/stdlib.h **** extern "C" {
  55:/usr/lib/avr/include/stdlib.h **** #endif
  56:/usr/lib/avr/include/stdlib.h **** 
  57:/usr/lib/avr/include/stdlib.h **** /** \file */
  58:/usr/lib/avr/include/stdlib.h **** 
  59:/usr/lib/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  60:/usr/lib/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  61:/usr/lib/avr/include/stdlib.h **** 
  62:/usr/lib/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  63:/usr/lib/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  64:/usr/lib/avr/include/stdlib.h **** */
  65:/usr/lib/avr/include/stdlib.h **** 
  66:/usr/lib/avr/include/stdlib.h **** /*@{*/
  67:/usr/lib/avr/include/stdlib.h **** /** Result type for function div(). */
  68:/usr/lib/avr/include/stdlib.h **** typedef struct {
  69:/usr/lib/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  70:/usr/lib/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  71:/usr/lib/avr/include/stdlib.h **** } div_t;
  72:/usr/lib/avr/include/stdlib.h **** 
  73:/usr/lib/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  74:/usr/lib/avr/include/stdlib.h **** typedef struct {
  75:/usr/lib/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  76:/usr/lib/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  77:/usr/lib/avr/include/stdlib.h **** } ldiv_t;
  78:/usr/lib/avr/include/stdlib.h **** 
  79:/usr/lib/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  80:/usr/lib/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  81:/usr/lib/avr/include/stdlib.h **** 
  82:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  83:/usr/lib/avr/include/stdlib.h **** 
  84:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  85:/usr/lib/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  86:/usr/lib/avr/include/stdlib.h **** #endif
  87:/usr/lib/avr/include/stdlib.h **** 
  88:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  89:/usr/lib/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  90:/usr/lib/avr/include/stdlib.h **** #endif
  91:/usr/lib/avr/include/stdlib.h **** 
  92:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  93:/usr/lib/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  94:/usr/lib/avr/include/stdlib.h **** #endif
  95:/usr/lib/avr/include/stdlib.h **** 
  96:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  97:/usr/lib/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
  98:/usr/lib/avr/include/stdlib.h **** #endif
  99:/usr/lib/avr/include/stdlib.h **** 
 100:/usr/lib/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 101:/usr/lib/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 102:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 103:/usr/lib/avr/include/stdlib.h **** # else
 104:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 105:/usr/lib/avr/include/stdlib.h **** # endif
 106:/usr/lib/avr/include/stdlib.h **** #endif
 107:/usr/lib/avr/include/stdlib.h **** 
 108:/usr/lib/avr/include/stdlib.h **** #endif
 109:/usr/lib/avr/include/stdlib.h **** 
 110:/usr/lib/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 111:/usr/lib/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 112:/usr/lib/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 113:/usr/lib/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 114:/usr/lib/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 115:/usr/lib/avr/include/stdlib.h **** 
 116:/usr/lib/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 117:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 118:/usr/lib/avr/include/stdlib.h **** */
 119:/usr/lib/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 120:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 121:/usr/lib/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 122:/usr/lib/avr/include/stdlib.h **** #endif
 123:/usr/lib/avr/include/stdlib.h **** 
 124:/usr/lib/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 125:/usr/lib/avr/include/stdlib.h ****     \c i.
 126:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 127:/usr/lib/avr/include/stdlib.h **** */
 128:/usr/lib/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 129:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 130:/usr/lib/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 131:/usr/lib/avr/include/stdlib.h **** #endif
 132:/usr/lib/avr/include/stdlib.h **** 
 133:/usr/lib/avr/include/stdlib.h **** /**
 134:/usr/lib/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 135:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 136:/usr/lib/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 137:/usr/lib/avr/include/stdlib.h ****      member of the array is specified by \c size.
 138:/usr/lib/avr/include/stdlib.h **** 
 139:/usr/lib/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 140:/usr/lib/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 141:/usr/lib/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 142:/usr/lib/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 143:/usr/lib/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 144:/usr/lib/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 145:/usr/lib/avr/include/stdlib.h ****      to match, or be greater than the array member.
 146:/usr/lib/avr/include/stdlib.h **** 
 147:/usr/lib/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 148:/usr/lib/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 149:/usr/lib/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 150:/usr/lib/avr/include/stdlib.h **** */
 151:/usr/lib/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 152:/usr/lib/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 153:/usr/lib/avr/include/stdlib.h **** 
 154:/usr/lib/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 155:/usr/lib/avr/include/stdlib.h **** /**
 156:/usr/lib/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 157:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 158:/usr/lib/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 159:/usr/lib/avr/include/stdlib.h **** */
 160:/usr/lib/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 161:/usr/lib/avr/include/stdlib.h **** /**
 162:/usr/lib/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 163:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 164:/usr/lib/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 165:/usr/lib/avr/include/stdlib.h **** */
 166:/usr/lib/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 167:/usr/lib/avr/include/stdlib.h **** 
 168:/usr/lib/avr/include/stdlib.h **** /**
 169:/usr/lib/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 170:/usr/lib/avr/include/stdlib.h ****      quicksort.
 171:/usr/lib/avr/include/stdlib.h **** 
 172:/usr/lib/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 173:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 174:/usr/lib/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 175:/usr/lib/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 176:/usr/lib/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 177:/usr/lib/avr/include/stdlib.h ****      pointing to the objects being compared.
 178:/usr/lib/avr/include/stdlib.h **** 
 179:/usr/lib/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 180:/usr/lib/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 181:/usr/lib/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 182:/usr/lib/avr/include/stdlib.h **** */
 183:/usr/lib/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 184:/usr/lib/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 185:/usr/lib/avr/include/stdlib.h **** 
 186:/usr/lib/avr/include/stdlib.h **** /**
 187:/usr/lib/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 188:/usr/lib/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 189:/usr/lib/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 190:/usr/lib/avr/include/stdlib.h **** 
 191:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 192:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 193:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 194:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 195:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 196:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 197:/usr/lib/avr/include/stdlib.h **** 
 198:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 199:/usr/lib/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 200:/usr/lib/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 201:/usr/lib/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 202:/usr/lib/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 203:/usr/lib/avr/include/stdlib.h **** 
 204:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 205:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 206:/usr/lib/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 207:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 208:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 209:/usr/lib/avr/include/stdlib.h **** 
 210:/usr/lib/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 211:/usr/lib/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 212:/usr/lib/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 213:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 214:/usr/lib/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 215:/usr/lib/avr/include/stdlib.h **** */
 216:/usr/lib/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 217:/usr/lib/avr/include/stdlib.h **** 
 218:/usr/lib/avr/include/stdlib.h **** /**
 219:/usr/lib/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 220:/usr/lib/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 221:/usr/lib/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 222:/usr/lib/avr/include/stdlib.h ****     special value 0.
 223:/usr/lib/avr/include/stdlib.h **** 
 224:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 225:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 226:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 227:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 228:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 229:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 230:/usr/lib/avr/include/stdlib.h **** 
 231:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 232:/usr/lib/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 233:/usr/lib/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 234:/usr/lib/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 235:/usr/lib/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 236:/usr/lib/avr/include/stdlib.h **** 
 237:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 238:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 239:/usr/lib/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 240:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 241:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 242:/usr/lib/avr/include/stdlib.h **** 
 243:/usr/lib/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 244:/usr/lib/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 245:/usr/lib/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 246:/usr/lib/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 247:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 248:/usr/lib/avr/include/stdlib.h ****     be performed, 0 is returned.
 249:/usr/lib/avr/include/stdlib.h **** */
 250:/usr/lib/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 251:/usr/lib/avr/include/stdlib.h **** 
 252:/usr/lib/avr/include/stdlib.h **** /**
 253:/usr/lib/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 254:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 255:/usr/lib/avr/include/stdlib.h **** 
 256:/usr/lib/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 257:/usr/lib/avr/include/stdlib.h **** 
 258:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 259:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 260:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 261:/usr/lib/avr/include/stdlib.h **** */
 262:/usr/lib/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 263:/usr/lib/avr/include/stdlib.h **** 
 264:/usr/lib/avr/include/stdlib.h **** /**
 265:/usr/lib/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 266:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 267:/usr/lib/avr/include/stdlib.h **** 
 268:/usr/lib/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 269:/usr/lib/avr/include/stdlib.h **** 
 270:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 271:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 272:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 273:/usr/lib/avr/include/stdlib.h **** */
 274:/usr/lib/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 275:/usr/lib/avr/include/stdlib.h **** 
 276:/usr/lib/avr/include/stdlib.h **** /**
 277:/usr/lib/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 278:/usr/lib/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 279:/usr/lib/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 280:/usr/lib/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 281:/usr/lib/avr/include/stdlib.h ****    are globally disabled.
 282:/usr/lib/avr/include/stdlib.h **** 
 283:/usr/lib/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 284:/usr/lib/avr/include/stdlib.h ****    execution.
 285:/usr/lib/avr/include/stdlib.h **** */
 286:/usr/lib/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 287:/usr/lib/avr/include/stdlib.h **** 
 288:/usr/lib/avr/include/stdlib.h **** /**
 289:/usr/lib/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 290:/usr/lib/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 291:/usr/lib/avr/include/stdlib.h **** 
 292:/usr/lib/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 293:/usr/lib/avr/include/stdlib.h ****    zero bytes.
 294:/usr/lib/avr/include/stdlib.h **** 
 295:/usr/lib/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 296:/usr/lib/avr/include/stdlib.h ****    details.
 297:/usr/lib/avr/include/stdlib.h **** */
 298:/usr/lib/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 299:/usr/lib/avr/include/stdlib.h **** 
 300:/usr/lib/avr/include/stdlib.h **** /**
 301:/usr/lib/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 302:/usr/lib/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 303:/usr/lib/avr/include/stdlib.h ****    NULL, no action occurs.
 304:/usr/lib/avr/include/stdlib.h **** */
 305:/usr/lib/avr/include/stdlib.h **** extern void free(void *__ptr);
 306:/usr/lib/avr/include/stdlib.h **** 
 307:/usr/lib/avr/include/stdlib.h **** /**
 308:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 309:/usr/lib/avr/include/stdlib.h **** */
 310:/usr/lib/avr/include/stdlib.h **** extern size_t __malloc_margin;
 311:/usr/lib/avr/include/stdlib.h **** 
 312:/usr/lib/avr/include/stdlib.h **** /**
 313:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 314:/usr/lib/avr/include/stdlib.h **** */
 315:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 316:/usr/lib/avr/include/stdlib.h **** 
 317:/usr/lib/avr/include/stdlib.h **** /**
 318:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 319:/usr/lib/avr/include/stdlib.h **** */
 320:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 321:/usr/lib/avr/include/stdlib.h **** 
 322:/usr/lib/avr/include/stdlib.h **** /**
 323:/usr/lib/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 324:/usr/lib/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 325:/usr/lib/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 326:/usr/lib/avr/include/stdlib.h **** */
 327:/usr/lib/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 328:/usr/lib/avr/include/stdlib.h **** 
 329:/usr/lib/avr/include/stdlib.h **** /**
 330:/usr/lib/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 331:/usr/lib/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 332:/usr/lib/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 333:/usr/lib/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 334:/usr/lib/avr/include/stdlib.h ****    region.
 335:/usr/lib/avr/include/stdlib.h **** 
 336:/usr/lib/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 337:/usr/lib/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 338:/usr/lib/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 339:/usr/lib/avr/include/stdlib.h **** 
 340:/usr/lib/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 341:/usr/lib/avr/include/stdlib.h ****    will behave identical to malloc().
 342:/usr/lib/avr/include/stdlib.h **** 
 343:/usr/lib/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 344:/usr/lib/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 345:/usr/lib/avr/include/stdlib.h **** */
 346:/usr/lib/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 347:/usr/lib/avr/include/stdlib.h **** 
 348:/usr/lib/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 349:/usr/lib/avr/include/stdlib.h **** 
 350:/usr/lib/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 351:/usr/lib/avr/include/stdlib.h **** 
 352:/usr/lib/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 353:/usr/lib/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 354:/usr/lib/avr/include/stdlib.h **** 
 355:/usr/lib/avr/include/stdlib.h **** /**
 356:/usr/lib/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 357:/usr/lib/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 358:/usr/lib/avr/include/stdlib.h **** 
 359:/usr/lib/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 360:/usr/lib/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 361:/usr/lib/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 362:/usr/lib/avr/include/stdlib.h **** 
 363:/usr/lib/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 364:/usr/lib/avr/include/stdlib.h ****      a value of 1.
 365:/usr/lib/avr/include/stdlib.h **** 
 366:/usr/lib/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 367:/usr/lib/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 368:/usr/lib/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 369:/usr/lib/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 370:/usr/lib/avr/include/stdlib.h ****      32-bit precision.
 371:/usr/lib/avr/include/stdlib.h **** */
 372:/usr/lib/avr/include/stdlib.h **** extern int rand(void);
 373:/usr/lib/avr/include/stdlib.h **** /**
 374:/usr/lib/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 375:/usr/lib/avr/include/stdlib.h **** */
 376:/usr/lib/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 377:/usr/lib/avr/include/stdlib.h **** 
 378:/usr/lib/avr/include/stdlib.h **** /**
 379:/usr/lib/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 380:/usr/lib/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 381:/usr/lib/avr/include/stdlib.h ****    so the function becomes re-entrant.
 382:/usr/lib/avr/include/stdlib.h **** */
 383:/usr/lib/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 384:/usr/lib/avr/include/stdlib.h **** /*@}*/
 385:/usr/lib/avr/include/stdlib.h **** 
 386:/usr/lib/avr/include/stdlib.h **** /*@{*/
 387:/usr/lib/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 388:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 389:/usr/lib/avr/include/stdlib.h **** */
 390:/usr/lib/avr/include/stdlib.h **** /**
 391:/usr/lib/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 392:/usr/lib/avr/include/stdlib.h **** 
 393:/usr/lib/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 394:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 395:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 396:/usr/lib/avr/include/stdlib.h **** 
 397:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 398:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 399:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 400:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 401:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 402:/usr/lib/avr/include/stdlib.h **** 
 403:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 404:/usr/lib/avr/include/stdlib.h **** 
 405:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 406:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 407:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 408:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 409:/usr/lib/avr/include/stdlib.h ****     
 410:/usr/lib/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 411:/usr/lib/avr/include/stdlib.h **** 
 412:/usr/lib/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 413:/usr/lib/avr/include/stdlib.h **** */
 414:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 415:/usr/lib/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 416:/usr/lib/avr/include/stdlib.h **** #else
 417:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 418:/usr/lib/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 419:/usr/lib/avr/include/stdlib.h **** {
 420:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 421:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 422:/usr/lib/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 423:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 424:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 425:/usr/lib/avr/include/stdlib.h **** 	return __s;
 426:/usr/lib/avr/include/stdlib.h ****     } else {
 427:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 428:/usr/lib/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 2041               		.loc 10 428 0
 2042 0640 4AE0      		ldi r20,lo8(10)
 2043 0642 8E01      		movw r16,r28
 2044 0644 0F5F      		subi r16,-1
 2045 0646 1F4F      		sbci r17,-1
 2046 0648 B801      		movw r22,r16
 2047 064a 852D      		mov r24,r5
 2048 064c 962D      		mov r25,r6
 2049 064e 00D0      		rcall __itoa_ncheck
 2050               	.LVL174:
 2051               	.LBE111:
 2052               	.LBE110:
 140:dialogs.h     **** 
 141:dialogs.h     **** 	itoa(workNum, buf, 10);
 142:dialogs.h     **** 	LCDPrint(buf);
 2053               		.loc 9 142 0
 2054 0650 C801      		movw r24,r16
 2055 0652 00D0      		rcall LCDPrint
 2056               	.LVL175:
 143:dialogs.h     **** 	count = strlen(buf);
 2057               		.loc 9 143 0
 2058 0654 F801      		movw r30,r16
 2059               		0:
 2060 0656 0190      		ld __tmp_reg__,Z+
 2061 0658 0020      		tst __tmp_reg__
 2062 065a 01F4      		brne 0b
 2063 065c 3197      		sbiw r30,1
 2064 065e 7E2E      		mov r7,r30
 2065 0660 701A      		sub r7,r16
 2066               	.LVL176:
 136:dialogs.h     **** 
 2067               		.loc 9 136 0
 2068 0662 E52C      		mov r14,r5
 2069 0664 F62C      		mov r15,r6
 135:dialogs.h     **** 	int workNum = defaultNum;
 2070               		.loc 9 135 0
 2071 0666 912C      		mov r9,__zero_reg__
 134:dialogs.h     **** 	char cursorState = cursorUnderNum;
 2072               		.loc 9 134 0
 2073 0668 812C      		mov r8,__zero_reg__
 2074               	.LVL177:
 2075               	.L165:
 144:dialogs.h     **** 
 145:dialogs.h     **** 	while (1) {
 146:dialogs.h     **** 		LCDLastLine();
 2076               		.loc 9 146 0
 2077 066a 00D0      		rcall LCDLastLine
 2078               	.LVL178:
 147:dialogs.h     **** 		// –†–∏—Å—É–µ–º –∫—É—Ä—Å–æ—Ä
 148:dialogs.h     **** 		if (cursorState == cursorUnderNum) {
 2079               		.loc 9 148 0
 2080 066c 9110      		cpse r9,__zero_reg__
 2081 066e 00C0      		rjmp .L147
 2082               	.LVL179:
 2083 0670 A12C      		mov r10,__zero_reg__
 2084 0672 B12C      		mov r11,__zero_reg__
 2085               	.LBB112:
 149:dialogs.h     **** 			for (int i = 0; i < pos; i++) {
 2086               		.loc 9 149 0
 2087 0674 C82C      		mov r12,r8
 2088 0676 D12C      		mov r13,__zero_reg__
 2089               	.L148:
 2090               	.LVL180:
 2091               		.loc 9 149 0 is_stmt 0 discriminator 1
 2092 0678 AC14      		cp r10,r12
 2093 067a BD04      		cpc r11,r13
 2094 067c 04F4      		brge .L183
 150:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 2095               		.loc 9 150 0 is_stmt 1 discriminator 2
 2096 067e 80E0      		ldi r24,lo8(.LC1)
 2097 0680 90E0      		ldi r25,hi8(.LC1)
 2098 0682 00D0      		rcall LCDPrint
 2099               	.LVL181:
 149:dialogs.h     **** 			for (int i = 0; i < pos; i++) {
 2100               		.loc 9 149 0 discriminator 2
 2101 0684 8FEF      		ldi r24,-1
 2102 0686 A81A      		sub r10,r24
 2103 0688 B80A      		sbc r11,r24
 2104               	.LVL182:
 2105 068a 00C0      		rjmp .L148
 2106               	.L183:
 2107               	.LBE112:
 151:dialogs.h     **** 			}
 152:dialogs.h     ****             LCDPrint(ARROW_TOP);
 2108               		.loc 9 152 0
 2109 068c 80E0      		ldi r24,lo8(.LC3)
 2110 068e 90E0      		ldi r25,hi8(.LC3)
 2111 0690 00C0      		rjmp .L181
 2112               	.LVL183:
 2113               	.L147:
 153:dialogs.h     **** 		}
 154:dialogs.h     **** 		if (cursorState == cursorUnderOk) {
 2114               		.loc 9 154 0
 2115 0692 91E0      		ldi r25,lo8(1)
 2116 0694 9912      		cpse r9,r25
 2117 0696 00C0      		rjmp .L151
 155:dialogs.h     **** 			LCDFirstLine();
 2118               		.loc 9 155 0
 2119 0698 00D0      		rcall LCDFirstLine
 2120               	.LVL184:
 156:dialogs.h     **** 			LCDCursorShift(11);
 2121               		.loc 9 156 0
 2122 069a 8BE0      		ldi r24,lo8(11)
 2123 069c 90E0      		ldi r25,0
 2124 069e 00C0      		rjmp .L182
 2125               	.L151:
 157:dialogs.h     ****             LCDPrint(ARROW_RIGHT);
 158:dialogs.h     **** 		}
 159:dialogs.h     **** 		if (cursorState == cursorUnderCancel) {
 160:dialogs.h     **** 			LCDLastLine();
 2126               		.loc 9 160 0
 2127 06a0 00D0      		rcall LCDLastLine
 2128               	.LVL185:
 161:dialogs.h     **** 			LCDCursorShift(7);
 2129               		.loc 9 161 0
 2130 06a2 87E0      		ldi r24,lo8(7)
 2131 06a4 90E0      		ldi r25,0
 2132               	.L182:
 2133 06a6 00D0      		rcall LCDCursorShift
 2134               	.LVL186:
 162:dialogs.h     ****             LCDPrint(ARROW_RIGHT);
 2135               		.loc 9 162 0
 2136 06a8 80E0      		ldi r24,lo8(.LC0)
 2137 06aa 90E0      		ldi r25,hi8(.LC0)
 2138               	.LVL187:
 2139               	.L181:
 2140 06ac 00D0      		rcall LCDPrint
 2141               	.LVL188:
 163:dialogs.h     **** 		}
 164:dialogs.h     **** 
 165:dialogs.h     **** 		// –î–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤–ª–µ–≤–æ
 166:dialogs.h     **** 		if (ReadBtnLeft()) {
 2142               		.loc 9 166 0
 2143 06ae 00D0      		rcall ReadBtnLeft
 2144               	.LVL189:
 2145 06b0 892B      		or r24,r25
 2146 06b2 01F0      		breq .L152
 167:dialogs.h     **** 			if (cursorState == cursorUnderNum) {
 2147               		.loc 9 167 0
 2148 06b4 9110      		cpse r9,__zero_reg__
 2149 06b6 00C0      		rjmp .L153
 168:dialogs.h     **** 				if (pos > 0) {
 2150               		.loc 9 168 0
 2151 06b8 8820      		tst r8
 2152 06ba 01F0      		breq .L154
 169:dialogs.h     **** 					LCDLastLine();
 2153               		.loc 9 169 0
 2154 06bc 00D0      		rcall LCDLastLine
 2155               	.LVL190:
 170:dialogs.h     **** 					LCDClearCurrLine();
 2156               		.loc 9 170 0
 2157 06be 00D0      		rcall LCDClearCurrLine
 2158               	.LVL191:
 171:dialogs.h     **** 					pos -= 1;
 2159               		.loc 9 171 0
 2160 06c0 8A94      		dec r8
 2161               	.LVL192:
 2162 06c2 00C0      		rjmp .L152
 2163               	.L154:
 2164               	.LVL193:
 172:dialogs.h     **** 				} else {
 173:dialogs.h     **** 					cursorState = cursorUnderCancel;
 174:dialogs.h     **** 					LCDLastLine();
 2165               		.loc 9 174 0
 2166 06c4 00D0      		rcall LCDLastLine
 2167               	.LVL194:
 175:dialogs.h     **** 					LCDClearCurrLine();
 2168               		.loc 9 175 0
 2169 06c6 00D0      		rcall LCDClearCurrLine
 2170               	.LVL195:
 173:dialogs.h     **** 					LCDLastLine();
 2171               		.loc 9 173 0
 2172 06c8 32E0      		ldi r19,lo8(2)
 2173 06ca 932E      		mov r9,r19
 2174 06cc 00C0      		rjmp .L152
 2175               	.LVL196:
 2176               	.L153:
 176:dialogs.h     **** 				}
 177:dialogs.h     **** 			} else if (cursorState == cursorUnderOk) {
 2177               		.loc 9 177 0
 2178 06ce E1E0      		ldi r30,lo8(1)
 2179 06d0 9E12      		cpse r9,r30
 2180 06d2 00C0      		rjmp .L155
 178:dialogs.h     **** 				LCDFirstLine();
 2181               		.loc 9 178 0
 2182 06d4 00D0      		rcall LCDFirstLine
 2183               	.LVL197:
 179:dialogs.h     **** 				LCDCursorShift(11);
 2184               		.loc 9 179 0
 2185 06d6 8BE0      		ldi r24,lo8(11)
 2186 06d8 90E0      		ldi r25,0
 2187 06da 00D0      		rcall LCDCursorShift
 2188               	.LVL198:
 180:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 2189               		.loc 9 180 0
 2190 06dc 80E0      		ldi r24,lo8(.LC1)
 2191 06de 90E0      		ldi r25,hi8(.LC1)
 2192 06e0 00D0      		rcall LCDPrint
 2193               	.LVL199:
 181:dialogs.h     **** 				cursorState = cursorUnderNum;
 182:dialogs.h     **** 				pos = count - 1;
 2194               		.loc 9 182 0
 2195 06e2 8824      		clr r8
 2196 06e4 8A94      		dec r8
 2197               	.LVL200:
 2198 06e6 870C      		add r8,r7
 2199               	.LVL201:
 181:dialogs.h     **** 				cursorState = cursorUnderNum;
 2200               		.loc 9 181 0
 2201 06e8 912C      		mov r9,__zero_reg__
 2202 06ea 00C0      		rjmp .L152
 2203               	.LVL202:
 2204               	.L155:
 183:dialogs.h     **** 			} else {
 184:dialogs.h     **** 				LCDLastLine();
 2205               		.loc 9 184 0
 2206 06ec 00D0      		rcall LCDLastLine
 2207               	.LVL203:
 185:dialogs.h     **** 				LCDCursorShift(7);
 2208               		.loc 9 185 0
 2209 06ee 87E0      		ldi r24,lo8(7)
 2210 06f0 90E0      		ldi r25,0
 2211 06f2 00D0      		rcall LCDCursorShift
 2212               	.LVL204:
 186:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 2213               		.loc 9 186 0
 2214 06f4 80E0      		ldi r24,lo8(.LC1)
 2215 06f6 90E0      		ldi r25,hi8(.LC1)
 2216 06f8 00D0      		rcall LCDPrint
 2217               	.LVL205:
 187:dialogs.h     **** 				cursorState = cursorUnderOk;
 2218               		.loc 9 187 0
 2219 06fa 9924      		clr r9
 2220 06fc 9394      		inc r9
 2221               	.LVL206:
 2222               	.L152:
 188:dialogs.h     **** 			}
 189:dialogs.h     **** 		}
 190:dialogs.h     **** 		// –î–≤–∏–≥–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤–ø—Ä–∞–≤–æ
 191:dialogs.h     ****         if (ReadBtnRight()) {
 2223               		.loc 9 191 0
 2224 06fe 00D0      		rcall ReadBtnRight
 2225               	.LVL207:
 2226 0700 892B      		or r24,r25
 2227 0702 01F0      		breq .L156
 192:dialogs.h     **** 			if (cursorState == cursorUnderNum) {
 2228               		.loc 9 192 0
 2229 0704 9110      		cpse r9,__zero_reg__
 2230 0706 00C0      		rjmp .L157
 193:dialogs.h     **** 				if (pos < (count - 1)) {
 2231               		.loc 9 193 0
 2232 0708 282D      		mov r18,r8
 2233 070a 30E0      		ldi r19,0
 2234 070c 872D      		mov r24,r7
 2235 070e 90E0      		ldi r25,0
 2236 0710 0197      		sbiw r24,1
 2237 0712 2817      		cp r18,r24
 2238 0714 3907      		cpc r19,r25
 2239 0716 04F4      		brge .L158
 194:dialogs.h     **** 					pos += 1;
 2240               		.loc 9 194 0
 2241 0718 8394      		inc r8
 2242               	.LVL208:
 2243 071a 00C0      		rjmp .L156
 2244               	.L158:
 2245               	.LVL209:
 195:dialogs.h     **** 				} else {
 196:dialogs.h     **** 					cursorState = cursorUnderOk;
 197:dialogs.h     **** 					LCDLastLine();
 2246               		.loc 9 197 0
 2247 071c 00D0      		rcall LCDLastLine
 2248               	.LVL210:
 198:dialogs.h     **** 					LCDClearCurrLine();
 2249               		.loc 9 198 0
 2250 071e 00D0      		rcall LCDClearCurrLine
 2251               	.LVL211:
 196:dialogs.h     **** 					LCDLastLine();
 2252               		.loc 9 196 0
 2253 0720 9924      		clr r9
 2254 0722 9394      		inc r9
 2255 0724 00C0      		rjmp .L156
 2256               	.LVL212:
 2257               	.L157:
 199:dialogs.h     **** 				}
 200:dialogs.h     **** 			} else if (cursorState == cursorUnderOk) {
 2258               		.loc 9 200 0
 2259 0726 F1E0      		ldi r31,lo8(1)
 2260 0728 9F12      		cpse r9,r31
 2261 072a 00C0      		rjmp .L159
 201:dialogs.h     **** 				LCDFirstLine();
 2262               		.loc 9 201 0
 2263 072c 00D0      		rcall LCDFirstLine
 2264               	.LVL213:
 202:dialogs.h     **** 				LCDCursorShift(11);
 2265               		.loc 9 202 0
 2266 072e 8BE0      		ldi r24,lo8(11)
 2267 0730 90E0      		ldi r25,0
 2268 0732 00D0      		rcall LCDCursorShift
 2269               	.LVL214:
 203:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 2270               		.loc 9 203 0
 2271 0734 80E0      		ldi r24,lo8(.LC1)
 2272 0736 90E0      		ldi r25,hi8(.LC1)
 2273 0738 00D0      		rcall LCDPrint
 2274               	.LVL215:
 204:dialogs.h     **** 				cursorState = cursorUnderCancel;
 2275               		.loc 9 204 0
 2276 073a 22E0      		ldi r18,lo8(2)
 2277 073c 922E      		mov r9,r18
 2278 073e 00C0      		rjmp .L156
 2279               	.LVL216:
 2280               	.L159:
 205:dialogs.h     **** 			} else {
 206:dialogs.h     **** 				LCDLastLine();
 2281               		.loc 9 206 0
 2282 0740 00D0      		rcall LCDLastLine
 2283               	.LVL217:
 207:dialogs.h     **** 				LCDCursorShift(7);
 2284               		.loc 9 207 0
 2285 0742 87E0      		ldi r24,lo8(7)
 2286 0744 90E0      		ldi r25,0
 2287 0746 00D0      		rcall LCDCursorShift
 2288               	.LVL218:
 208:dialogs.h     ****                 LCDPrint(SYMB_SPACE);
 2289               		.loc 9 208 0
 2290 0748 80E0      		ldi r24,lo8(.LC1)
 2291 074a 90E0      		ldi r25,hi8(.LC1)
 2292 074c 00D0      		rcall LCDPrint
 2293               	.LVL219:
 209:dialogs.h     **** 				cursorState = cursorUnderNum;
 2294               		.loc 9 209 0
 2295 074e 912C      		mov r9,__zero_reg__
 210:dialogs.h     **** 				pos = 0;
 2296               		.loc 9 210 0
 2297 0750 812C      		mov r8,__zero_reg__
 2298               	.LVL220:
 2299               	.L156:
 211:dialogs.h     **** 			}
 212:dialogs.h     ****         }
 213:dialogs.h     **** 		// –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ä–∞–∑—Ä—è–¥ –∏–ª–∏ –≤—ã—Ö–æ–¥–∏–º
 214:dialogs.h     ****         if (ReadBtnTop()) {
 2300               		.loc 9 214 0
 2301 0752 00D0      		rcall ReadBtnTop
 2302               	.LVL221:
 2303 0754 892B      		or r24,r25
 2304 0756 01F0      		breq .L160
 215:dialogs.h     **** 
 216:dialogs.h     **** 			if (cursorState == cursorUnderNum) {
 2305               		.loc 9 216 0
 2306 0758 9110      		cpse r9,__zero_reg__
 2307 075a 00C0      		rjmp .L160
 2308               	.LVL222:
 2309               	.LBB113:
 217:dialogs.h     **** 				char lastcount = count;
 218:dialogs.h     **** 				int workSumm = power(10, count - pos - 1);
 2310               		.loc 9 218 0
 2311 075c 672D      		mov r22,r7
 2312 075e 70E0      		ldi r23,0
 2313 0760 6819      		sub r22,r8
 2314 0762 7109      		sbc r23,__zero_reg__
 2315 0764 6150      		subi r22,1
 2316 0766 7109      		sbc r23,__zero_reg__
 2317 0768 8AE0      		ldi r24,lo8(10)
 2318 076a 90E0      		ldi r25,0
 2319 076c 00D0      		rcall power
 2320               	.LVL223:
 219:dialogs.h     **** 				if ((workNum + workSumm) < 10001) {
 2321               		.loc 9 219 0
 2322 076e 6701      		movw r12,r14
 2323 0770 C80E      		add r12,r24
 2324 0772 D91E      		adc r13,r25
 2325 0774 81E1      		ldi r24,17
 2326 0776 C816      		cp r12,r24
 2327 0778 87E2      		ldi r24,39
 2328 077a D806      		cpc r13,r24
 2329               	.LVL224:
 2330 077c 04F4      		brge .L160
 220:dialogs.h     **** 					LCDFirstLine();
 2331               		.loc 9 220 0
 2332 077e 00D0      		rcall LCDFirstLine
 2333               	.LVL225:
 221:dialogs.h     **** 					LCDClearCurrLine();
 2334               		.loc 9 221 0
 2335 0780 00D0      		rcall LCDClearCurrLine
 2336               	.LVL226:
 222:dialogs.h     **** 					LCDFirstLine();
 2337               		.loc 9 222 0
 2338 0782 00D0      		rcall LCDFirstLine
 2339               	.LVL227:
 2340               	.LBB114:
 2341               	.LBB115:
 2342               		.loc 10 428 0
 2343 0784 4AE0      		ldi r20,lo8(10)
 2344 0786 B801      		movw r22,r16
 2345 0788 C601      		movw r24,r12
 2346 078a 00D0      		rcall __itoa_ncheck
 2347               	.LVL228:
 2348               	.LBE115:
 2349               	.LBE114:
 223:dialogs.h     **** 
 224:dialogs.h     **** 					workNum += workSumm;
 225:dialogs.h     **** 					itoa(workNum, buf, 10);
 226:dialogs.h     **** 					LCDPrint(buf);
 2350               		.loc 9 226 0
 2351 078c C801      		movw r24,r16
 2352 078e 00D0      		rcall LCDPrint
 2353               	.LVL229:
 227:dialogs.h     **** 					lastcount = count;
 228:dialogs.h     **** 					count = strlen(buf);
 2354               		.loc 9 228 0
 2355 0790 F801      		movw r30,r16
 2356               		0:
 2357 0792 0190      		ld __tmp_reg__,Z+
 2358 0794 0020      		tst __tmp_reg__
 2359 0796 01F4      		brne 0b
 2360 0798 CF01      		movw r24,r30
 2361 079a 0197      		sbiw r24,1
 2362 079c 5C01      		movw r10,r24
 2363 079e A01A      		sub r10,r16
 2364 07a0 B10A      		sbc r11,r17
 2365               	.LVL230:
 229:dialogs.h     **** 					// –ï—Å–ª–∏ —á–∏—Å–ª–æ —Å—Ç–∞–ª–æ –¥–ª–∏–Ω–Ω–µ–µ
 230:dialogs.h     **** 					if (lastcount < count) {
 2366               		.loc 9 230 0
 2367 07a2 7A14      		cp r7,r10
 2368 07a4 00F4      		brsh .L166
 231:dialogs.h     **** 						LCDLastLine();
 2369               		.loc 9 231 0
 2370 07a6 00D0      		rcall LCDLastLine
 2371               	.LVL231:
 232:dialogs.h     **** 						LCDClearCurrLine();
 2372               		.loc 9 232 0
 2373 07a8 00D0      		rcall LCDClearCurrLine
 2374               	.LVL232:
 233:dialogs.h     **** 						pos = pos + 1;
 2375               		.loc 9 233 0
 2376 07aa 8394      		inc r8
 2377               	.LVL233:
 2378               	.L166:
 2379 07ac 7601      		movw r14,r12
 2380 07ae 7A2C      		mov r7,r10
 2381               	.LVL234:
 2382               	.L160:
 2383               	.LBE113:
 234:dialogs.h     **** 					}
 235:dialogs.h     **** 
 236:dialogs.h     **** 				}
 237:dialogs.h     ****             }
 238:dialogs.h     **** 		}
 239:dialogs.h     **** 
 240:dialogs.h     **** 		// –£–º–µ–Ω—å—à–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ä–∞–∑–¥–µ–ª
 241:dialogs.h     ****         if (ReadBtnBottom()) {
 2384               		.loc 9 241 0
 2385 07b0 00D0      		rcall ReadBtnBottom
 2386               	.LVL235:
 2387 07b2 892B      		or r24,r25
 2388 07b4 01F0      		breq .L161
 242:dialogs.h     **** 
 243:dialogs.h     **** 			if (cursorState == cursorUnderNum) {
 2389               		.loc 9 243 0
 2390 07b6 9110      		cpse r9,__zero_reg__
 2391 07b8 00C0      		rjmp .L161
 2392               	.LVL236:
 2393               	.LBB116:
 244:dialogs.h     **** 				char lastcount = count;
 245:dialogs.h     **** 				int workSumm = power(10, count - pos - 1);
 2394               		.loc 9 245 0
 2395 07ba A82C      		mov r10,r8
 2396 07bc B12C      		mov r11,__zero_reg__
 2397 07be 672D      		mov r22,r7
 2398 07c0 70E0      		ldi r23,0
 2399 07c2 6A19      		sub r22,r10
 2400 07c4 7B09      		sbc r23,r11
 2401 07c6 6150      		subi r22,1
 2402 07c8 7109      		sbc r23,__zero_reg__
 2403 07ca 8AE0      		ldi r24,lo8(10)
 2404 07cc 90E0      		ldi r25,0
 2405 07ce 00D0      		rcall power
 2406               	.LVL237:
 246:dialogs.h     **** 				if ((workNum - workSumm) >= 0) {
 2407               		.loc 9 246 0
 2408 07d0 6701      		movw r12,r14
 2409 07d2 C81A      		sub r12,r24
 2410 07d4 D90A      		sbc r13,r25
 2411 07d6 D7FC      		sbrc r13,7
 2412 07d8 00C0      		rjmp .L161
 247:dialogs.h     **** 					LCDFirstLine();
 2413               		.loc 9 247 0
 2414 07da 00D0      		rcall LCDFirstLine
 2415               	.LVL238:
 248:dialogs.h     **** 					LCDClearCurrLine();
 2416               		.loc 9 248 0
 2417 07dc 00D0      		rcall LCDClearCurrLine
 2418               	.LVL239:
 249:dialogs.h     **** 					LCDFirstLine();
 2419               		.loc 9 249 0
 2420 07de 00D0      		rcall LCDFirstLine
 2421               	.LVL240:
 2422               	.LBB117:
 2423               	.LBB118:
 2424               		.loc 10 428 0
 2425 07e0 4AE0      		ldi r20,lo8(10)
 2426 07e2 B801      		movw r22,r16
 2427 07e4 C601      		movw r24,r12
 2428 07e6 00D0      		rcall __itoa_ncheck
 2429               	.LVL241:
 2430               	.LBE118:
 2431               	.LBE117:
 250:dialogs.h     **** 
 251:dialogs.h     **** 					workNum -= workSumm;
 252:dialogs.h     **** 					itoa(workNum, buf, 10);
 253:dialogs.h     **** 					LCDPrint(buf);
 2432               		.loc 9 253 0
 2433 07e8 C801      		movw r24,r16
 2434 07ea 00D0      		rcall LCDPrint
 2435               	.LVL242:
 254:dialogs.h     **** 					lastcount = count;
 255:dialogs.h     **** 					count = strlen(buf);
 2436               		.loc 9 255 0
 2437 07ec F801      		movw r30,r16
 2438               		0:
 2439 07ee 0190      		ld __tmp_reg__,Z+
 2440 07f0 0020      		tst __tmp_reg__
 2441 07f2 01F4      		brne 0b
 2442 07f4 CF01      		movw r24,r30
 2443 07f6 0197      		sbiw r24,1
 2444 07f8 1C01      		movw r2,r24
 2445 07fa 201A      		sub r2,r16
 2446 07fc 310A      		sbc r3,r17
 2447               	.LVL243:
 256:dialogs.h     **** 				}
 257:dialogs.h     **** 				// –ï—Å–ª–∏ —á–∏—Å–ª–æ —Å—Ç–∞–ª–æ –∫–æ—Ä–æ—á–µ
 258:dialogs.h     **** 				if (lastcount > count) {
 2448               		.loc 9 258 0
 2449 07fe 2714      		cp r2,r7
 2450 0800 00F4      		brsh .L168
 259:dialogs.h     **** 					LCDLastLine();
 2451               		.loc 9 259 0
 2452 0802 00D0      		rcall LCDLastLine
 2453               	.LVL244:
 260:dialogs.h     **** 					LCDClearCurrLine();
 2454               		.loc 9 260 0
 2455 0804 00D0      		rcall LCDClearCurrLine
 2456               	.LVL245:
 261:dialogs.h     **** 					if (pos > (count - 1)) {
 2457               		.loc 9 261 0
 2458 0806 C101      		movw r24,r2
 2459 0808 9927      		clr r25
 2460 080a A816      		cp r10,r24
 2461 080c B906      		cpc r11,r25
 2462 080e 04F0      		brlt .L168
 262:dialogs.h     **** 						pos = count - 1;
 2463               		.loc 9 262 0
 2464 0810 8824      		clr r8
 2465 0812 8A94      		dec r8
 2466               	.LVL246:
 2467 0814 820C      		add r8,r2
 2468               	.LVL247:
 2469               	.L168:
 2470 0816 7601      		movw r14,r12
 2471 0818 722C      		mov r7,r2
 2472               	.LVL248:
 2473               	.L161:
 2474               	.LBE116:
 263:dialogs.h     **** 					}
 264:dialogs.h     **** 				}
 265:dialogs.h     ****             }
 266:dialogs.h     ****         }
 267:dialogs.h     **** 
 268:dialogs.h     ****         // –î–µ–ª–∞–µ–º –≤—ã–±–æ—Ä
 269:dialogs.h     ****         if (ReadBtnSelect()) {
 2475               		.loc 9 269 0
 2476 081a 00D0      		rcall ReadBtnSelect
 2477               	.LVL249:
 2478 081c 892B      		or r24,r25
 2479 081e 01F0      		breq .L162
 270:dialogs.h     ****             if (cursorState != cursorUnderCancel) {
 2480               		.loc 9 270 0
 2481 0820 92E0      		ldi r25,lo8(2)
 2482 0822 9916      		cp r9,r25
 2483 0824 01F0      		breq .L164
 2484 0826 5E2C      		mov r5,r14
 2485               	.LVL250:
 2486 0828 6F2C      		mov r6,r15
 2487 082a 00C0      		rjmp .L164
 2488               	.LVL251:
 2489               	.L162:
 271:dialogs.h     ****                 return workNum;
 272:dialogs.h     ****             } else {
 273:dialogs.h     ****                 return defaultNum;
 274:dialogs.h     ****             }
 275:dialogs.h     ****         }
 276:dialogs.h     **** 
 277:dialogs.h     **** 		LCDFirstLine();
 2490               		.loc 9 277 0
 2491 082c 00D0      		rcall LCDFirstLine
 2492               	.LVL252:
 278:dialogs.h     **** 		LCDCursorShift(12);
 2493               		.loc 9 278 0
 2494 082e 8CE0      		ldi r24,lo8(12)
 2495 0830 90E0      		ldi r25,0
 2496 0832 00D0      		rcall LCDCursorShift
 2497               	.LVL253:
 279:dialogs.h     ****         LCDPrint(TEXT_OK);
 2498               		.loc 9 279 0
 2499 0834 80E0      		ldi r24,lo8(.LC4)
 2500 0836 90E0      		ldi r25,hi8(.LC4)
 2501 0838 00D0      		rcall LCDPrint
 2502               	.LVL254:
 280:dialogs.h     **** 
 281:dialogs.h     **** 		LCDLastLine();
 2503               		.loc 9 281 0
 2504 083a 00D0      		rcall LCDLastLine
 2505               	.LVL255:
 282:dialogs.h     **** 		LCDCursorShift(8);
 2506               		.loc 9 282 0
 2507 083c 88E0      		ldi r24,lo8(8)
 2508 083e 90E0      		ldi r25,0
 2509 0840 00D0      		rcall LCDCursorShift
 2510               	.LVL256:
 283:dialogs.h     ****         LCDPrint(TEXT_CANCEL);
 2511               		.loc 9 283 0
 2512 0842 80E0      		ldi r24,lo8(.LC5)
 2513 0844 90E0      		ldi r25,hi8(.LC5)
 2514 0846 00D0      		rcall LCDPrint
 2515               	.LVL257:
 284:dialogs.h     **** 	}
 2516               		.loc 9 284 0
 2517 0848 00C0      		rjmp .L165
 2518               	.LVL258:
 2519               	.L164:
 285:dialogs.h     **** 	return workNum;
 286:dialogs.h     **** }
 2520               		.loc 9 286 0
 2521 084a 852D      		mov r24,r5
 2522 084c 962D      		mov r25,r6
 2523               	/* epilogue start */
 2524 084e 2A96      		adiw r28,10
 2525 0850 0FB6      		in __tmp_reg__,__SREG__
 2526 0852 F894      		cli
 2527 0854 DEBF      		out __SP_H__,r29
 2528 0856 0FBE      		out __SREG__,__tmp_reg__
 2529 0858 CDBF      		out __SP_L__,r28
 2530 085a DF91      		pop r29
 2531 085c CF91      		pop r28
 2532 085e 1F91      		pop r17
 2533 0860 0F91      		pop r16
 2534 0862 FF90      		pop r15
 2535 0864 EF90      		pop r14
 2536               	.LVL259:
 2537 0866 DF90      		pop r13
 2538 0868 CF90      		pop r12
 2539 086a BF90      		pop r11
 2540 086c AF90      		pop r10
 2541 086e 9F90      		pop r9
 2542               	.LVL260:
 2543 0870 8F90      		pop r8
 2544               	.LVL261:
 2545 0872 7F90      		pop r7
 2546               	.LVL262:
 2547 0874 6F90      		pop r6
 2548 0876 5F90      		pop r5
 2549 0878 3F90      		pop r3
 2550 087a 2F90      		pop r2
 2551 087c 0895      		ret
 2552               		.cfi_endproc
 2553               	.LFE47:
 2555               	.global	setRelayState
 2557               	setRelayState:
 2558               	.LFB48:
  23:Relay.h       **** 
 2559               		.loc 1 23 0
 2560               		.cfi_startproc
 2561               	.LVL263:
 2562               	/* prologue: function */
 2563               	/* frame size = 0 */
 2564               	/* stack size = 0 */
 2565               	.L__stack_usage = 0
  25:Relay.h       ****     {
 2566               		.loc 1 25 0
 2567 087e 8230      		cpi r24,2
 2568 0880 9105      		cpc r25,__zero_reg__
 2569 0882 01F4      		brne .L185
  28:Relay.h       ****             PORTC |= (1 << 5);
 2570               		.loc 1 28 0
 2571 0884 6111      		cpse r22,__zero_reg__
 2572 0886 00C0      		rjmp setRelayState.part.2
 2573               	.LVL264:
 2574               	.L186:
  30:Relay.h       ****         } else {
  31:Relay.h       ****             PORTC &= ~(1 << 5);
 2575               		.loc 1 31 0
 2576 0888 AD98      		cbi 0x15,5
 2577 088a 0895      		ret
 2578               	.L185:
  32:Relay.h       ****         }
  33:Relay.h       ****     } else {
  34:Relay.h       ****         if (isOpen) {
  35:Relay.h       ****             PORTD |= (1 << RelayNum);
 2579               		.loc 1 35 0
 2580 088c 92B3      		in r25,0x12
 2581 088e 21E0      		ldi r18,lo8(1)
 2582 0890 30E0      		ldi r19,0
 2583 0892 082E      		mov r0,r24
 2584 0894 00C0      		rjmp 2f
 2585               		1:
 2586 0896 220F      		lsl r18
 2587               		2:
 2588 0898 0A94      		dec r0
 2589 089a 02F4      		brpl 1b
  34:Relay.h       ****             PORTD |= (1 << RelayNum);
 2590               		.loc 1 34 0
 2591 089c 6623      		tst r22
 2592 089e 01F0      		breq .L188
 2593               		.loc 1 35 0
 2594 08a0 922B      		or r25,r18
 2595 08a2 92BB      		out 0x12,r25
 2596 08a4 0895      		ret
 2597               	.L188:
  36:Relay.h       ****         } else {
  37:Relay.h       ****             PORTD &= ~(1 << RelayNum);
 2598               		.loc 1 37 0
 2599 08a6 2095      		com r18
 2600 08a8 2923      		and r18,r25
 2601 08aa 22BB      		out 0x12,r18
 2602 08ac 0895      		ret
 2603               		.cfi_endproc
 2604               	.LFE48:
 2606               	.global	initIO
 2608               	initIO:
 2609               	.LFB49:
 196:main.c        **** /* ------------------------------------------------------------------------- */
 197:main.c        **** 
 198:main.c        **** 
 199:main.c        **** 
 200:main.c        **** // –ú–æ–∏ –º–æ–¥—É–ª–∏
 201:main.c        **** #include "EEPROM_mem.h"
 202:main.c        **** #include "sysfunc.h"
 203:main.c        **** #include "LCDMelt.h"
 204:main.c        **** #include "dialogs.h"
 205:main.c        **** #include "Relay.h"
 206:main.c        **** #include "Keyboard.h"
 207:main.c        **** #include "menu.h"
 208:main.c        **** 
 209:main.c        **** int def_pulse_duration;
 210:main.c        **** int def_pause_duration;
 211:main.c        **** int def_impulse_count;
 212:main.c        **** int def_mode;
 213:main.c        **** 
 214:main.c        **** #define COUNTOFMODES 4
 215:main.c        **** char listOfModes[][MAX_LCD_LINE] =
 216:main.c        **** 		{ "NAMUR 2.2K-5.6K", "NAMUR 2.2K-40K",
 217:main.c        **** 				"\xD0\xE0\xE7\xF0\xFB\xE2"/*–†–∞–∑—Ä—ã–≤*/,
 218:main.c        **** 				"\xC2\xF1\xE5 \xF0\xE5\xEB\xE5" /*–í—Å–µ —Ä–µ–ª–µ*/};
 219:main.c        **** 
 220:main.c        **** // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Ä—Ç–æ–≤ –≤–≤–æ–¥–∞\–≤—ã–≤–æ–¥–∞
 221:main.c        **** void initIO() {
 2610               		.loc 2 221 0
 2611               		.cfi_startproc
 2612               	/* prologue: function */
 2613               	/* frame size = 0 */
 2614               	/* stack size = 0 */
 2615               	.L__stack_usage = 0
 222:main.c        **** 
 223:main.c        **** 	// –ü–æ—Ä—Ç –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω—ã—Ö –≤ —ç–∫—Ä–∞–Ω
 224:main.c        **** 	PORTD = 0;
 2616               		.loc 2 224 0
 2617 08ae 12BA      		out 0x12,__zero_reg__
 225:main.c        **** 	DDRD = 0xFF;
 2618               		.loc 2 225 0
 2619 08b0 8FEF      		ldi r24,lo8(-1)
 2620 08b2 81BB      		out 0x11,r24
 226:main.c        **** 
 227:main.c        **** 	// –ù–∞ –≤—ã–≤–æ–¥ –ø–∏–Ω—ã LCD E –∏ A0, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –Ω–∞ –≤—Ö–æ–¥
 228:main.c        **** 	PORTB = 0;
 2621               		.loc 2 228 0
 2622 08b4 18BA      		out 0x18,__zero_reg__
 229:main.c        **** 	DDRB = 0b00000011;
 2623               		.loc 2 229 0
 2624 08b6 83E0      		ldi r24,lo8(3)
 2625 08b8 87BB      		out 0x17,r24
 230:main.c        **** 
 231:main.c        **** 	// –ù–∞ –≤—ã–≤–æ–¥ –ø–∏–Ω—ã –æ—Ç–≤–µ—á–∞—é—â–∏–µ –∑–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–ª–µ, –Ω–∞ –≤—Ö–æ–¥
 232:main.c        **** 	PORTC = 0;
 2626               		.loc 2 232 0
 2627 08ba 15BA      		out 0x15,__zero_reg__
 233:main.c        ****     DDRC = 0b00100000;
 2628               		.loc 2 233 0
 2629 08bc 80E2      		ldi r24,lo8(32)
 2630 08be 84BB      		out 0x14,r24
 234:main.c        **** 
 235:main.c        ****     // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º USB
 236:main.c        ****     usbInit();
 2631               		.loc 2 236 0
 2632 08c0 00D0      		rcall usbInit
 2633               	.LVL265:
 237:main.c        ****     usbDeviceDisconnect();
 2634               		.loc 2 237 0
 2635 08c2 8B9A      		sbi 0x11,3
 2636 08c4 0895      		ret
 2637               		.cfi_endproc
 2638               	.LFE49:
 2640               		.section	.rodata.str1.1
 2641               	.LC6:
 2642 0024 4849 442D 		.string	"HID-USB ACTIVATING START"
 2642      5553 4220 
 2642      4143 5449 
 2642      5641 5449 
 2642      4E47 2053 
 2643               	.LC7:
 2644 003d C7E0 EFF3 		.string	"\307\340\357\363\361\362\350\362\374?"
 2644      F1F2 E8F2 
 2644      FC3F 00
 2645               	.LC8:
 2646 0048 2E00      		.string	"."
 2647               	.LC9:
 2648 004a 2041 6E74 		.string	" Anton Sinitsyn"
 2648      6F6E 2053 
 2648      696E 6974 
 2648      7379 6E00 
 2649               	.LC10:
 2650 005a 5275 7373 		.string	"Russia 2015 oct"
 2650      6961 2032 
 2650      3031 3520 
 2650      6F63 7400 
 2651               		.section	.text.startup,"ax",@progbits
 2652               	.global	main
 2654               	main:
 2655               	.LFB50:
 238:main.c        **** }
 239:main.c        **** 
 240:main.c        **** int main(void) {
 2656               		.loc 2 240 0
 2657               		.cfi_startproc
 2658 0000 CF93      		push r28
 2659               	.LCFI57:
 2660               		.cfi_def_cfa_offset 3
 2661               		.cfi_offset 28, -2
 2662 0002 DF93      		push r29
 2663               	.LCFI58:
 2664               		.cfi_def_cfa_offset 4
 2665               		.cfi_offset 29, -3
 2666 0004 CDB7      		in r28,__SP_L__
 2667 0006 DEB7      		in r29,__SP_H__
 2668               	.LCFI59:
 2669               		.cfi_def_cfa_register 28
 2670 0008 A897      		sbiw r28,40
 2671               	.LCFI60:
 2672               		.cfi_def_cfa_offset 44
 2673 000a 0FB6      		in __tmp_reg__,__SREG__
 2674 000c F894      		cli
 2675 000e DEBF      		out __SP_H__,r29
 2676 0010 0FBE      		out __SREG__,__tmp_reg__
 2677 0012 CDBF      		out __SP_L__,r28
 2678               	/* prologue: function */
 2679               	/* frame size = 40 */
 2680               	/* stack size = 42 */
 2681               	.L__stack_usage = 42
 241:main.c        **** 
 242:main.c        **** 	// –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–æ—Ä—Ç—ã
 243:main.c        **** 	initIO();
 2682               		.loc 2 243 0
 2683 0014 00D0      		rcall initIO
 2684               	.LVL266:
 244:main.c        **** 
 245:main.c        **** 	// –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
 246:main.c        ****     def_pulse_duration = readPulseDuration();
 2685               		.loc 2 246 0
 2686 0016 00D0      		rcall readPulseDuration
 2687               	.LVL267:
 2688 0018 5C01      		movw r10,r24
 2689 001a 9093 0000 		sts def_pulse_duration+1,r25
 2690 001e 8093 0000 		sts def_pulse_duration,r24
 247:main.c        **** 	def_pause_duration = readPauseDuration();
 2691               		.loc 2 247 0
 2692 0022 00D0      		rcall readPauseDuration
 2693               	.LVL268:
 2694 0024 6C01      		movw r12,r24
 2695 0026 9093 0000 		sts def_pause_duration+1,r25
 2696 002a 8093 0000 		sts def_pause_duration,r24
 248:main.c        **** 	def_impulse_count = readImpulseCount();
 2697               		.loc 2 248 0
 2698 002e 00D0      		rcall readImpulseCount
 2699               	.LVL269:
 2700 0030 7C01      		movw r14,r24
 2701 0032 9093 0000 		sts def_impulse_count+1,r25
 2702 0036 8093 0000 		sts def_impulse_count,r24
 249:main.c        ****     def_mode = readMode();
 2703               		.loc 2 249 0
 2704 003a 00D0      		rcall readMode
 2705               	.LVL270:
 2706 003c 9093 0000 		sts def_mode+1,r25
 2707 0040 8093 0000 		sts def_mode,r24
 250:main.c        **** 
 251:main.c        ****     if (def_pulse_duration == -1) {
 2708               		.loc 2 251 0
 2709 0044 AB20      		and r10,r11
 2710 0046 A094      		com r10
 2711 0048 01F4      		brne .L191
 252:main.c        ****         def_pulse_duration = 100;
 2712               		.loc 2 252 0
 2713 004a 84E6      		ldi r24,lo8(100)
 2714 004c 90E0      		ldi r25,0
 2715 004e 9093 0000 		sts def_pulse_duration+1,r25
 2716 0052 8093 0000 		sts def_pulse_duration,r24
 2717               	.L191:
 253:main.c        ****     }
 254:main.c        ****     if (def_pause_duration == -1) {
 2718               		.loc 2 254 0
 2719 0056 CD20      		and r12,r13
 2720 0058 C094      		com r12
 2721 005a 01F4      		brne .L192
 255:main.c        ****         def_pause_duration = 100;
 2722               		.loc 2 255 0
 2723 005c 84E6      		ldi r24,lo8(100)
 2724 005e 90E0      		ldi r25,0
 2725 0060 9093 0000 		sts def_pause_duration+1,r25
 2726 0064 8093 0000 		sts def_pause_duration,r24
 2727               	.L192:
 256:main.c        ****     }
 257:main.c        ****     if (def_impulse_count == -1) {
 2728               		.loc 2 257 0
 2729 0068 EF20      		and r14,r15
 2730 006a E094      		com r14
 2731 006c 01F4      		brne .L193
 258:main.c        ****         def_impulse_count = 100;
 2732               		.loc 2 258 0
 2733 006e 84E6      		ldi r24,lo8(100)
 2734 0070 90E0      		ldi r25,0
 2735 0072 9093 0000 		sts def_impulse_count+1,r25
 2736 0076 8093 0000 		sts def_impulse_count,r24
 2737               	.L193:
 259:main.c        ****     }
 260:main.c        **** 
 261:main.c        **** 	// –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —ç–∫—Ä–∞–Ω
 262:main.c        **** 	LCDinit();
 2738               		.loc 2 262 0
 2739 007a 00D0      		rcall LCDinit
 2740               	.LVL271:
 263:main.c        **** 	LCDClrScr();
 2741               		.loc 2 263 0
 2742 007c 00D0      		rcall LCDClrScr
 2743               	.LVL272:
 264:main.c        **** 	LCDFirstLine();
 2744               		.loc 2 264 0
 2745 007e 00D0      		rcall LCDFirstLine
 2746               	.LVL273:
 265:main.c        **** 
 266:main.c        **** 	// –ü–µ—á–∞—Ç–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
 267:main.c        **** 	boolean CanUpdate = true;
 268:main.c        **** 	main_menu_index = 0;
 2747               		.loc 2 268 0
 2748 0080 1092 0000 		sts main_menu_index,__zero_reg__
 267:main.c        **** 	main_menu_index = 0;
 2749               		.loc 2 267 0
 2750 0084 01E0      		ldi r16,lo8(1)
 269:main.c        **** 
 270:main.c        **** // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø—Ä–æ–≥—Ä–∞–º–º—ã
 271:main.c        **** 	while (1) {
 272:main.c        **** 
 273:main.c        **** 		if (CanUpdate) {
 274:main.c        **** 			printMenu(main_menu, main_menu_index);
 275:main.c        **** 			CanUpdate = false;
 276:main.c        **** 		}
 277:main.c        **** 
 278:main.c        ****         // –õ–∏—Å—Ç–∞–µ–º –≤–≤–µ—Ä—Ö
 279:main.c        **** 		if (ReadBtnTop())
 280:main.c        **** 		{
 281:main.c        ****             if ((menustate == MENUSTATE_MAIN) && (main_menu_index > 0)) {
 282:main.c        ****                 if (menu_duration == 1) {
 283:main.c        ****                     menu_duration = 0;
 284:main.c        ****                 }
 285:main.c        ****                 main_menu_index -= 1;
 286:main.c        ****                 CanUpdate = true;
 2751               		.loc 2 286 0
 2752 0086 11E0      		ldi r17,lo8(1)
 2753               	.LVL274:
 2754               	.L194:
 273:main.c        **** 			printMenu(main_menu, main_menu_index);
 2755               		.loc 2 273 0
 2756 0088 0023      		tst r16
 2757 008a 01F0      		breq .L196
 2758               	.L238:
 274:main.c        **** 			CanUpdate = false;
 2759               		.loc 2 274 0
 2760 008c 6091 0000 		lds r22,main_menu_index
 2761 0090 70E0      		ldi r23,0
 2762 0092 80E0      		ldi r24,lo8(main_menu)
 2763 0094 90E0      		ldi r25,hi8(main_menu)
 2764 0096 00D0      		rcall printMenu
 2765               	.LVL275:
 2766               	.L196:
 279:main.c        **** 		{
 2767               		.loc 2 279 0
 2768 0098 00D0      		rcall ReadBtnTop
 2769               	.LVL276:
 2770 009a 892B      		or r24,r25
 2771 009c 01F0      		breq .L227
 281:main.c        ****                 if (menu_duration == 1) {
 2772               		.loc 2 281 0
 2773 009e 8091 0000 		lds r24,menustate
 2774 00a2 8111      		cpse r24,__zero_reg__
 2775 00a4 00C0      		rjmp .L227
 281:main.c        ****                 if (menu_duration == 1) {
 2776               		.loc 2 281 0 is_stmt 0 discriminator 1
 2777 00a6 8091 0000 		lds r24,main_menu_index
 2778 00aa 8823      		tst r24
 2779 00ac 01F0      		breq .L227
 282:main.c        ****                     menu_duration = 0;
 2780               		.loc 2 282 0 is_stmt 1
 2781 00ae 9091 0000 		lds r25,menu_duration
 2782 00b2 9130      		cpi r25,lo8(1)
 2783 00b4 01F4      		brne .L198
 283:main.c        ****                 }
 2784               		.loc 2 283 0
 2785 00b6 1092 0000 		sts menu_duration,__zero_reg__
 2786               	.L198:
 285:main.c        ****                 CanUpdate = true;
 2787               		.loc 2 285 0
 2788 00ba 8150      		subi r24,lo8(-(-1))
 2789 00bc 8093 0000 		sts main_menu_index,r24
 2790               	.LVL277:
 2791               		.loc 2 286 0
 2792 00c0 01E0      		ldi r16,lo8(1)
 2793 00c2 00C0      		rjmp .L197
 2794               	.LVL278:
 2795               	.L227:
 2796 00c4 00E0      		ldi r16,0
 2797               	.LVL279:
 2798               	.L197:
 287:main.c        ****             }
 288:main.c        **** 		}
 289:main.c        **** 
 290:main.c        ****         // –õ–∏—Å—Ç–∞–µ–º –≤–Ω–∏–∑
 291:main.c        **** 		if (ReadBtnBottom())
 2799               		.loc 2 291 0
 2800 00c6 00D0      		rcall ReadBtnBottom
 2801               	.LVL280:
 2802 00c8 892B      		or r24,r25
 2803 00ca 01F0      		breq .L199
 292:main.c        **** 		{
 293:main.c        ****             if ((menustate == MENUSTATE_MAIN) && (main_menu_index < (MENU_ITEMS_COUNT - 1))) {
 2804               		.loc 2 293 0
 2805 00cc 8091 0000 		lds r24,menustate
 2806 00d0 8111      		cpse r24,__zero_reg__
 2807 00d2 00C0      		rjmp .L199
 2808               		.loc 2 293 0 is_stmt 0 discriminator 1
 2809 00d4 8091 0000 		lds r24,main_menu_index
 2810 00d8 8630      		cpi r24,lo8(6)
 2811 00da 00F4      		brsh .L199
 294:main.c        ****                 if (menu_duration == 0) {
 2812               		.loc 2 294 0 is_stmt 1
 2813 00dc 9091 0000 		lds r25,menu_duration
 2814 00e0 9111      		cpse r25,__zero_reg__
 2815 00e2 00C0      		rjmp .L200
 295:main.c        ****                     menu_duration = 1;
 2816               		.loc 2 295 0
 2817 00e4 1093 0000 		sts menu_duration,r17
 2818               	.L200:
 296:main.c        ****                 }
 297:main.c        ****                 main_menu_index += 1;
 2819               		.loc 2 297 0
 2820 00e8 8F5F      		subi r24,lo8(-(1))
 2821 00ea 8093 0000 		sts main_menu_index,r24
 2822               	.LVL281:
 298:main.c        ****                 CanUpdate = true;
 2823               		.loc 2 298 0
 2824 00ee 01E0      		ldi r16,lo8(1)
 2825               	.LVL282:
 2826               	.L199:
 299:main.c        **** 			}
 300:main.c        **** 		}
 301:main.c        **** 
 302:main.c        **** 		// –ù–∞–∂–∞—Ç–∞ –ø—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –∫–æ—Ç–æ—Ä–∞—è –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É
 303:main.c        **** 		if (ReadBtnSelect()) {
 2827               		.loc 2 303 0
 2828 00f0 00D0      		rcall ReadBtnSelect
 2829               	.LVL283:
 2830 00f2 892B      		or r24,r25
 2831 00f4 01F0      		breq .L194
 304:main.c        **** 			switch (main_menu_index) {
 2832               		.loc 2 304 0
 2833 00f6 8091 0000 		lds r24,main_menu_index
 2834 00fa 90E0      		ldi r25,0
 2835 00fc 8730      		cpi r24,7
 2836 00fe 9105      		cpc r25,__zero_reg__
 2837 0100 00F4      		brsh .L238
 2838 0102 FC01      		movw r30,r24
 2839 0104 E050      		subi r30,lo8(-(gs(.L202)))
 2840 0106 F040      		sbci r31,hi8(-(gs(.L202)))
 2841 0108 0994      		ijmp
 2842               		.section	.progmem.gcc_sw_table,"ax",@progbits
 2843               		.p2align	1
 2844               	.L202:
 2845 0000 00C0      		rjmp .L201
 2846 0002 00C0      		rjmp .L203
 2847 0004 00C0      		rjmp .L204
 2848 0006 00C0      		rjmp .L205
 2849 0008 00C0      		rjmp .L206
 2850 000a 00C0      		rjmp .L207
 2851 000c 00C0      		rjmp .L208
 2852               		.section	.text.startup
 2853               	.L201:
 305:main.c        **** 			case 0: // –î–ª–∏—Ç–µ–ª—å—Å–Ω–æ—Å—Ç—å –∏–º–ø—É–ª—å—Å–∞
 306:main.c        **** 				def_pulse_duration = getNumber(def_pulse_duration);
 2854               		.loc 2 306 0
 2855 010a 8091 0000 		lds r24,def_pulse_duration
 2856 010e 9091 0000 		lds r25,def_pulse_duration+1
 2857 0112 00D0      		rcall getNumber
 2858               	.LVL284:
 2859 0114 9093 0000 		sts def_pulse_duration+1,r25
 2860 0118 8093 0000 		sts def_pulse_duration,r24
 307:main.c        **** 				writePulseDuration(def_pulse_duration);
 2861               		.loc 2 307 0
 2862 011c 00D0      		rcall writePulseDuration
 2863               	.LVL285:
 308:main.c        **** 				break;
 2864               		.loc 2 308 0
 2865 011e 00C0      		rjmp .L238
 2866               	.LVL286:
 2867               	.L203:
 309:main.c        **** 			case 1: // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–∞—É–∑—ã
 310:main.c        **** 				def_pause_duration = getNumber(def_pause_duration);
 2868               		.loc 2 310 0
 2869 0120 8091 0000 		lds r24,def_pause_duration
 2870 0124 9091 0000 		lds r25,def_pause_duration+1
 2871 0128 00D0      		rcall getNumber
 2872               	.LVL287:
 2873 012a 9093 0000 		sts def_pause_duration+1,r25
 2874 012e 8093 0000 		sts def_pause_duration,r24
 311:main.c        **** 				writePauseDuration(def_pause_duration);
 2875               		.loc 2 311 0
 2876 0132 00D0      		rcall writePauseDuration
 2877               	.LVL288:
 312:main.c        **** 				break;
 2878               		.loc 2 312 0
 2879 0134 00C0      		rjmp .L238
 2880               	.LVL289:
 2881               	.L204:
 313:main.c        **** 			case 2: // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–º–ø—É–ª—å—Å–æ–≤
 314:main.c        **** 				def_impulse_count = getNumber(def_impulse_count);
 2882               		.loc 2 314 0
 2883 0136 8091 0000 		lds r24,def_impulse_count
 2884 013a 9091 0000 		lds r25,def_impulse_count+1
 2885 013e 00D0      		rcall getNumber
 2886               	.LVL290:
 2887 0140 9093 0000 		sts def_impulse_count+1,r25
 2888 0144 8093 0000 		sts def_impulse_count,r24
 315:main.c        **** 				writeImpulseCount(def_impulse_count);
 2889               		.loc 2 315 0
 2890 0148 00D0      		rcall writeImpulseCount
 2891               	.LVL291:
 316:main.c        **** 				break;
 2892               		.loc 2 316 0
 2893 014a 00C0      		rjmp .L238
 2894               	.LVL292:
 2895               	.L205:
 317:main.c        **** 			case 3: // –°–≤—è–∑—å —Å –ü–ö
 318:main.c        ****                 LCDClrScr();
 2896               		.loc 2 318 0
 2897 014c 00D0      		rcall LCDClrScr
 2898               	.LVL293:
 319:main.c        ****                 LCDFirstLine();
 2899               		.loc 2 319 0
 2900 014e 00D0      		rcall LCDFirstLine
 2901               	.LVL294:
 320:main.c        ****                 LCDPrint("HID-USB ACTIVATING START");
 2902               		.loc 2 320 0
 2903 0150 80E0      		ldi r24,lo8(.LC6)
 2904 0152 90E0      		ldi r25,hi8(.LC6)
 2905 0154 00D0      		rcall LCDPrint
 2906               	.LVL295:
 321:main.c        **** 
 322:main.c        ****                 usbDeviceConnect();     // –ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è
 2907               		.loc 2 322 0
 2908 0156 8B98      		cbi 0x11,3
 323:main.c        **** 
 324:main.c        ****                 sei();                  // —Ä–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
 2909               		.loc 2 324 0
 2910               	/* #APP */
 2911               	 ;  324 "main.c" 1
 2912 0158 7894      		sei
 2913               	 ;  0 "" 2
 2914               	/* #NOAPP */
 2915               	.L209:
 325:main.c        **** 
 326:main.c        ****                 for(;;){                // –≥–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≥—Ä–∞–º–º—ã
 327:main.c        ****                     usbPoll();          // —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –Ω–∞–¥–æ —Ä–µ–≥—É–ª—è—Ä–Ω–æ –≤—ã–∑
 2916               		.loc 2 327 0 discriminator 1
 2917 015a 00D0      		rcall usbPoll
 2918               	.LVL296:
 2919 015c 00C0      		rjmp .L209
 2920               	.L206:
 328:main.c        ****                 }
 329:main.c        **** 
 330:main.c        **** 				break;
 331:main.c        **** 			case 4: // –†–µ–∂–∏–º
 332:main.c        **** 				def_mode = selectFromList(listOfModes, COUNTOFMODES);
 2921               		.loc 2 332 0
 2922 015e 64E0      		ldi r22,lo8(4)
 2923 0160 70E0      		ldi r23,0
 2924 0162 80E0      		ldi r24,lo8(listOfModes)
 2925 0164 90E0      		ldi r25,hi8(listOfModes)
 2926 0166 00D0      		rcall selectFromList
 2927               	.LVL297:
 2928 0168 9093 0000 		sts def_mode+1,r25
 2929 016c 8093 0000 		sts def_mode,r24
 333:main.c        **** 				writeMode(def_mode);
 2930               		.loc 2 333 0
 2931 0170 00D0      		rcall writeMode
 2932               	.LVL298:
 334:main.c        **** 				break;
 2933               		.loc 2 334 0
 2934 0172 00C0      		rjmp .L238
 2935               	.LVL299:
 2936               	.L207:
 335:main.c        **** 			case 5: // –ó–∞–ø—É—Å—Ç–∏—Ç—å
 336:main.c        ****                 if (msgBox("\xC7\xE0\xEF\xF3\xF1\xF2\xE8\xF2\xFC?") == true) {
 2937               		.loc 2 336 0
 2938 0174 80E0      		ldi r24,lo8(.LC7)
 2939 0176 90E0      		ldi r25,hi8(.LC7)
 2940 0178 00D0      		rcall msgBox
 2941               	.LVL300:
 2942 017a 0197      		sbiw r24,1
 2943 017c 01F0      		breq .+2
 2944 017e 00C0      		rjmp .L238
 2945               	.LBB150:
 337:main.c        **** 
 338:main.c        **** 					LCDClrScr();
 2946               		.loc 2 338 0
 2947 0180 00D0      		rcall LCDClrScr
 2948               	.LVL301:
 339:main.c        **** 					LCDFirstLine();
 2949               		.loc 2 339 0
 2950 0182 00D0      		rcall LCDFirstLine
 2951               	.LVL302:
 340:main.c        **** 
 341:main.c        **** 					// –û–ø—Ä–µ–¥–µ–ª–∏–º –∏–∑ —Å–∫–æ–ª—å–∫–∏—Ö –∏–º–ø—É–ª—å—Å–æ–≤ —Å–æ—Å—Ç–æ–∏—Ç –æ–¥–∏–Ω —à–∞–≥ 
 342:main.c        **** 					int step = round(def_impulse_count / 16);
 2952               		.loc 2 342 0
 2953 0184 8091 0000 		lds r24,def_impulse_count
 2954 0188 9091 0000 		lds r25,def_impulse_count+1
 2955 018c 97FD      		sbrc r25,7
 2956 018e 0F96      		adiw r24,15
 2957               	.L211:
 2958 0190 BC01      		movw r22,r24
 2959 0192 44E0      		ldi r20,4
 2960               		1:
 2961 0194 7595      		asr r23
 2962 0196 6795      		ror r22
 2963 0198 4A95      		dec r20
 2964 019a 01F4      		brne 1b
 2965 019c 8827      		clr r24
 2966 019e 77FD      		sbrc r23,7
 2967 01a0 8095      		com r24
 2968 01a2 982F      		mov r25,r24
 2969 01a4 00D0      		rcall __floatsisf
 2970               	.LVL303:
 2971 01a6 00D0      		rcall round
 2972               	.LVL304:
 2973 01a8 00D0      		rcall __fixsfsi
 2974               	.LVL305:
 2975 01aa 3B01      		movw r6,r22
 2976               	.LVL306:
 2977               	.LBB151:
 343:main.c        **** 					int pos = 0;
 344:main.c        **** 					int progress = 0;
 345:main.c        **** 
 346:main.c        **** 					for (int i = 0; i < def_impulse_count; i++) {
 2978               		.loc 2 346 0
 2979 01ac C12C      		mov r12,__zero_reg__
 2980 01ae D12C      		mov r13,__zero_reg__
 2981               	.LBE151:
 344:main.c        **** 
 2982               		.loc 2 344 0
 2983 01b0 A12C      		mov r10,__zero_reg__
 2984 01b2 B12C      		mov r11,__zero_reg__
 343:main.c        **** 					int pos = 0;
 2985               		.loc 2 343 0
 2986 01b4 E12C      		mov r14,__zero_reg__
 2987 01b6 F12C      		mov r15,__zero_reg__
 2988               	.LVL307:
 2989               	.L212:
 2990               	.LBB176:
 2991               		.loc 2 346 0 discriminator 1
 2992 01b8 8091 0000 		lds r24,def_impulse_count
 2993 01bc 9091 0000 		lds r25,def_impulse_count+1
 2994 01c0 C816      		cp r12,r24
 2995 01c2 D906      		cpc r13,r25
 2996 01c4 04F0      		brlt .+2
 2997 01c6 00C0      		rjmp .L238
 2998               	.LBB152:
 347:main.c        **** 						// –í–∫–ª—é—á–∞–µ–º —Ä–µ–ª–µ
 348:main.c        **** 						double pause_ms = def_pulse_duration;
 2999               		.loc 2 348 0
 3000 01c8 8090 0000 		lds r8,def_pulse_duration
 3001 01cc 9090 0000 		lds r9,def_pulse_duration+1
 3002               	.LVL308:
 349:main.c        **** 
 350:main.c        **** 						// NAMUR 2.2K-5.6K
 351:main.c        **** 						if (def_mode == 0) {
 3003               		.loc 2 351 0
 3004 01d0 8091 0000 		lds r24,def_mode
 3005 01d4 9091 0000 		lds r25,def_mode+1
 3006 01d8 0097      		sbiw r24,0
 3007 01da 01F4      		brne .L213
 3008               	.LVL309:
 3009               	.LBB153:
 3010               	.LBB154:
 3011 01dc 00D0      		rcall setRelayState.part.2
 3012               	.LVL310:
 3013 01de 00C0      		rjmp .L214
 3014               	.LVL311:
 3015               	.L213:
 3016               	.LBE154:
 3017               	.LBE153:
 352:main.c        **** 							setRelayState(RELAY_BOTTOM, true);
 353:main.c        **** 						} else
 354:main.c        **** 						// NAMUR 2.2K-40K
 355:main.c        **** 						if (def_mode == 1) {
 3018               		.loc 2 355 0
 3019 01e0 8130      		cpi r24,1
 3020 01e2 9105      		cpc r25,__zero_reg__
 3021 01e4 01F4      		brne .L215
 3022               	.LVL312:
 3023               	.LBB155:
 3024               	.LBB156:
  35:Relay.h       ****         } else {
 3025               		.loc 1 35 0
 3026 01e6 919A      		sbi 0x12,1
 3027 01e8 00C0      		rjmp .L214
 3028               	.LVL313:
 3029               	.L215:
 3030               	.LBE156:
 3031               	.LBE155:
 356:main.c        **** 							setRelayState(RELAY_MIDDLE, true);
 357:main.c        **** 						} else
 358:main.c        **** 						// –†–∞–∑—Ä—ã–≤
 359:main.c        **** 						if (def_mode == 2) {
 3032               		.loc 2 359 0
 3033 01ea 0297      		sbiw r24,2
 3034 01ec 01F0      		breq .L239
 3035               	.LVL314:
 3036               	.LBB157:
 3037               	.LBB158:
 3038 01ee 00D0      		rcall setRelayState.part.2
 3039               	.LVL315:
 3040               	.LBE158:
 3041               	.LBE157:
 3042               	.LBB159:
 3043               	.LBB160:
  35:Relay.h       ****         } else {
 3044               		.loc 1 35 0
 3045 01f0 919A      		sbi 0x12,1
 3046               	.LVL316:
 3047               	.L239:
 3048               	.LBE160:
 3049               	.LBE159:
 3050               	.LBB161:
 3051               	.LBB162:
 3052 01f2 909A      		sbi 0x12,0
 3053               	.LVL317:
 3054               	.L214:
 3055               	.LBE162:
 3056               	.LBE161:
 360:main.c        **** 							setRelayState(RELAY_TOP, true);
 361:main.c        **** 						} else // –í—Å–µ
 362:main.c        **** 						{
 363:main.c        **** 							setRelayState(RELAY_BOTTOM, true);
 364:main.c        **** 							setRelayState(RELAY_MIDDLE, true);
 365:main.c        **** 							setRelayState(RELAY_TOP, true);
 366:main.c        **** 						}
 367:main.c        **** 						// –ñ–¥—ë–º
 368:main.c        **** 						delay_ms(pause_ms);
 3057               		.loc 2 368 0
 3058 01f4 C401      		movw r24,r8
 3059 01f6 00D0      		rcall delay_ms
 3060               	.LVL318:
 369:main.c        **** 
 370:main.c        **** 						// –í—ã–∫–ª—é—á–∞–µ–º —Ä–µ–ª–µ
 371:main.c        **** 
 372:main.c        **** 						// NAMUR 2.2K-5.6K
 373:main.c        **** 						if (def_mode == 0) {
 3061               		.loc 2 373 0
 3062 01f8 8091 0000 		lds r24,def_mode
 3063 01fc 9091 0000 		lds r25,def_mode+1
 3064 0200 0097      		sbiw r24,0
 3065 0202 01F4      		brne .L217
 3066               	.LVL319:
 3067               	.LBB163:
 3068               	.LBB164:
  31:Relay.h       ****         }
 3069               		.loc 1 31 0
 3070 0204 AD98      		cbi 0x15,5
 3071 0206 00C0      		rjmp .L218
 3072               	.LVL320:
 3073               	.L217:
 3074               	.LBE164:
 3075               	.LBE163:
 374:main.c        **** 							setRelayState(RELAY_BOTTOM, false);
 375:main.c        **** 						} else
 376:main.c        **** 						// NAMUR 2.2K-40K
 377:main.c        **** 						if (def_mode == 1) {
 3076               		.loc 2 377 0
 3077 0208 8130      		cpi r24,1
 3078 020a 9105      		cpc r25,__zero_reg__
 3079 020c 01F4      		brne .L219
 3080               	.LVL321:
 3081               	.LBB165:
 3082               	.LBB166:
 3083               		.loc 1 37 0
 3084 020e 9198      		cbi 0x12,1
 3085 0210 00C0      		rjmp .L218
 3086               	.LVL322:
 3087               	.L219:
 3088               	.LBE166:
 3089               	.LBE165:
 378:main.c        **** 							setRelayState(RELAY_MIDDLE, false);
 379:main.c        **** 						} else
 380:main.c        **** 						// –†–∞–∑—Ä—ã–≤
 381:main.c        **** 						if (def_mode == 2) {
 3090               		.loc 2 381 0
 3091 0212 0297      		sbiw r24,2
 3092 0214 01F0      		breq .L240
 3093               	.LVL323:
 3094               	.LBB167:
 3095               	.LBB168:
  31:Relay.h       ****         }
 3096               		.loc 1 31 0
 3097 0216 AD98      		cbi 0x15,5
 3098               	.LVL324:
 3099               	.LBE168:
 3100               	.LBE167:
 3101               	.LBB169:
 3102               	.LBB170:
 3103               		.loc 1 37 0
 3104 0218 9198      		cbi 0x12,1
 3105               	.LVL325:
 3106               	.L240:
 3107               	.LBE170:
 3108               	.LBE169:
 3109               	.LBB171:
 3110               	.LBB172:
 3111 021a 9098      		cbi 0x12,0
 3112               	.LVL326:
 3113               	.L218:
 3114               	.LBE172:
 3115               	.LBE171:
 382:main.c        **** 							setRelayState(RELAY_TOP, false);
 383:main.c        **** 						} else // –í—Å–µ
 384:main.c        **** 						{
 385:main.c        **** 							setRelayState(RELAY_BOTTOM, false);
 386:main.c        **** 							setRelayState(RELAY_MIDDLE, false);
 387:main.c        **** 							setRelayState(RELAY_TOP, false);
 388:main.c        **** 						}
 389:main.c        **** 
 390:main.c        **** 						delay_ms(def_pause_duration);
 3116               		.loc 2 390 0
 3117 021c 8091 0000 		lds r24,def_pause_duration
 3118 0220 9091 0000 		lds r25,def_pause_duration+1
 3119 0224 00D0      		rcall delay_ms
 3120               	.LVL327:
 391:main.c        **** 
 392:main.c        **** 						pos += 1;
 3121               		.loc 2 392 0
 3122 0226 8FEF      		ldi r24,-1
 3123 0228 E81A      		sub r14,r24
 3124 022a F80A      		sbc r15,r24
 3125               	.LVL328:
 393:main.c        **** 						if (pos > step) {
 3126               		.loc 2 393 0
 3127 022c 6E14      		cp r6,r14
 3128 022e 7F04      		cpc r7,r15
 3129 0230 04F4      		brge .L221
 3130               	.LBB173:
 394:main.c        **** 							LCDFirstLine();
 3131               		.loc 2 394 0
 3132 0232 00D0      		rcall LCDFirstLine
 3133               	.LVL329:
 395:main.c        **** 							LCDCursorShift(progress);
 3134               		.loc 2 395 0
 3135 0234 C501      		movw r24,r10
 3136 0236 00D0      		rcall LCDCursorShift
 3137               	.LVL330:
 396:main.c        ****                             LCDPrint(".");
 3138               		.loc 2 396 0
 3139 0238 80E0      		ldi r24,lo8(.LC8)
 3140 023a 90E0      		ldi r25,hi8(.LC8)
 3141 023c 00D0      		rcall LCDPrint
 3142               	.LVL331:
 397:main.c        **** 							progress += 1;
 3143               		.loc 2 397 0
 3144 023e 8FEF      		ldi r24,-1
 3145 0240 A81A      		sub r10,r24
 3146 0242 B80A      		sbc r11,r24
 3147               	.LVL332:
 398:main.c        **** 							LCDLastLine();
 3148               		.loc 2 398 0
 3149 0244 00D0      		rcall LCDLastLine
 3150               	.LVL333:
 3151               	.LBB174:
 3152               	.LBB175:
 3153               		.loc 10 428 0
 3154 0246 4AE0      		ldi r20,lo8(10)
 3155 0248 BE01      		movw r22,r28
 3156 024a 6F5F      		subi r22,-1
 3157 024c 7F4F      		sbci r23,-1
 3158 024e C601      		movw r24,r12
 3159 0250 00D0      		rcall __itoa_ncheck
 3160               	.LVL334:
 3161               	.LBE175:
 3162               	.LBE174:
 399:main.c        **** 							char buf[40];
 400:main.c        **** 							itoa(i, buf, 10);
 401:main.c        **** 							LCDPrint(buf);
 3163               		.loc 2 401 0
 3164 0252 CE01      		movw r24,r28
 3165 0254 0196      		adiw r24,1
 3166 0256 00D0      		rcall LCDPrint
 3167               	.LVL335:
 402:main.c        **** 							pos = 0;
 3168               		.loc 2 402 0
 3169 0258 E12C      		mov r14,__zero_reg__
 3170 025a F12C      		mov r15,__zero_reg__
 3171               	.LVL336:
 3172               	.L221:
 3173               	.LBE173:
 3174               	.LBE152:
 346:main.c        **** 						// –í–∫–ª—é—á–∞–µ–º —Ä–µ–ª–µ
 3175               		.loc 2 346 0
 3176 025c 8FEF      		ldi r24,-1
 3177 025e C81A      		sub r12,r24
 3178 0260 D80A      		sbc r13,r24
 3179               	.LVL337:
 3180 0262 00C0      		rjmp .L212
 3181               	.LVL338:
 3182               	.L208:
 3183               	.LBE176:
 3184               	.LBE150:
 403:main.c        **** 						}
 404:main.c        **** 					}
 405:main.c        **** 				}
 406:main.c        **** 				break;
 407:main.c        **** 			case 6:
 408:main.c        **** 				//–û–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
 409:main.c        **** 				LCDClrScr();
 3185               		.loc 2 409 0
 3186 0264 00D0      		rcall LCDClrScr
 3187               	.LVL339:
 410:main.c        **** 				LCDFirstLine();
 3188               		.loc 2 410 0
 3189 0266 00D0      		rcall LCDFirstLine
 3190               	.LVL340:
 411:main.c        ****                 LCDPrint(" Anton Sinitsyn");
 3191               		.loc 2 411 0
 3192 0268 80E0      		ldi r24,lo8(.LC9)
 3193 026a 90E0      		ldi r25,hi8(.LC9)
 3194 026c 00D0      		rcall LCDPrint
 3195               	.LVL341:
 412:main.c        **** 				LCDLastLine();
 3196               		.loc 2 412 0
 3197 026e 00D0      		rcall LCDLastLine
 3198               	.LVL342:
 413:main.c        ****                 LCDPrint("Russia 2015 oct");
 3199               		.loc 2 413 0
 3200 0270 80E0      		ldi r24,lo8(.LC10)
 3201 0272 90E0      		ldi r25,hi8(.LC10)
 3202 0274 00D0      		rcall LCDPrint
 3203               	.LVL343:
 3204               	.L224:
 414:main.c        **** 				while (1) {
 415:main.c        **** 					if (ReadBtnLeft() | ReadBtnTop() | ReadBtnBottom() | ReadBtnRight() | ReadBtnSelect()) {
 3205               		.loc 2 415 0
 3206 0276 00D0      		rcall ReadBtnLeft
 3207               	.LVL344:
 3208 0278 7C01      		movw r14,r24
 3209 027a 00D0      		rcall ReadBtnTop
 3210               	.LVL345:
 3211 027c E82A      		or r14,r24
 3212 027e F92A      		or r15,r25
 3213 0280 00D0      		rcall ReadBtnBottom
 3214               	.LVL346:
 3215 0282 E82A      		or r14,r24
 3216 0284 F92A      		or r15,r25
 3217 0286 00D0      		rcall ReadBtnRight
 3218               	.LVL347:
 3219 0288 E82A      		or r14,r24
 3220 028a F92A      		or r15,r25
 3221 028c 00D0      		rcall ReadBtnSelect
 3222               	.LVL348:
 3223 028e 8E29      		or r24,r14
 3224 0290 9F29      		or r25,r15
 3225 0292 892B      		or r24,r25
 3226 0294 01F0      		breq .L224
 3227 0296 00C0      		rjmp .L238
 3228               		.cfi_endproc
 3229               	.LFE50:
 3231               	.global	listOfModes
 3232               		.data
 3235               	listOfModes:
 3236 0000 4E41 4D55 		.string	"NAMUR 2.2K-5.6K"
 3236      5220 322E 
 3236      324B 2D35 
 3236      2E36 4B00 
 3237 0010 4E41 4D55 		.string	"NAMUR 2.2K-40K"
 3237      5220 322E 
 3237      324B 2D34 
 3237      304B 00
 3238 001f 00        		.zero	1
 3239 0020 D0E0 E7F0 		.string	"\320\340\347\360\373\342"
 3239      FBE2 00
 3240 0027 0000 0000 		.zero	9
 3240      0000 0000 
 3240      00
 3241 0030 C2F1 E520 		.string	"\302\361\345 \360\345\353\345"
 3241      F0E5 EBE5 
 3241      00
 3242 0039 0000 0000 		.zero	7
 3242      0000 00
 3243               		.comm	def_mode,2,1
 3244               		.comm	def_impulse_count,2,1
 3245               		.comm	def_pause_duration,2,1
 3246               		.comm	def_pulse_duration,2,1
 3247               	.global	main_menu
 3250               	main_menu:
 3251 0040 C8EC EFF3 		.string	"\310\354\357\363\353\374\361"
 3251      EBFC F100 
 3252 0048 0000 0000 		.zero	8
 3252      0000 0000 
 3253 0050 CFE0 F3E7 		.string	"\317\340\363\347\340"
 3253      E000 
 3254 0056 0000 0000 		.zero	10
 3254      0000 0000 
 3254      0000 
 3255 0060 D7E8 F1EB 		.string	"\327\350\361\353\356 \350\354\357\363\353\374\361\356\342"
 3255      EE20 E8EC 
 3255      EFF3 EBFC 
 3255      F1EE E200 
 3256 0070 D1E2 FFE7 		.string	"\321\342\377\347\374 \361 \317\312"
 3256      FC20 F120 
 3256      CFCA 00
 3257 007b 0000 0000 		.zero	5
 3257      00
 3258 0080 D0E5 E6E8 		.string	"\320\345\346\350\354"
 3258      EC00 
 3259 0086 0000 0000 		.zero	10
 3259      0000 0000 
 3259      0000 
 3260 0090 C7E0 EFF3 		.string	"\307\340\357\363\361\352"
 3260      F1EA 00
 3261 0097 0000 0000 		.zero	9
 3261      0000 0000 
 3261      00
 3262 00a0 CE20 F3F1 		.string	"\316 \363\361\362\360\356\351\361\362\342\345"
 3262      F2F0 EEE9 
 3262      F1F2 E2E5 
 3262      00
 3263 00ad 0000 00   		.zero	3
 3264               	.global	menu_duration
 3265               		.section .bss
 3268               	menu_duration:
 3269 0000 00        		.zero	1
 3270               	.global	main_menu_index
 3273               	main_menu_index:
 3274 0001 00        		.zero	1
 3275               	.global	menustate
 3278               	menustate:
 3279 0002 00        		.zero	1
 3280               	.global	eeprom_mode
 3281               		.section	.eeprom,"aw",@progbits
 3284               	eeprom_mode:
 3285 0000 0000      		.zero	2
 3286               	.global	eeprom_impulse_count
 3289               	eeprom_impulse_count:
 3290 0002 E803      		.word	1000
 3291               	.global	eeprom_pause_duration
 3294               	eeprom_pause_duration:
 3295 0004 E803      		.word	1000
 3296               	.global	eeprom_pulse_duration
 3299               	eeprom_pulse_duration:
 3300 0006 D007      		.word	2000
 3301               		.local	bytesRemaining
 3302               		.comm	bytesRemaining,1,1
 3303               		.local	currentAddress
 3304               		.comm	currentAddress,1,1
 3305               	.global	usbHidReportDescriptor
 3306               		.data
 3309               	usbHidReportDescriptor:
 3310 00b0 06        		.byte	6
 3311 00b1 00        		.byte	0
 3312 00b2 FF        		.byte	-1
 3313 00b3 09        		.byte	9
 3314 00b4 01        		.byte	1
 3315 00b5 A1        		.byte	-95
 3316 00b6 01        		.byte	1
 3317 00b7 15        		.byte	21
 3318 00b8 00        		.byte	0
 3319 00b9 26        		.byte	38
 3320 00ba FF        		.byte	-1
 3321 00bb 00        		.byte	0
 3322 00bc 75        		.byte	117
 3323 00bd 08        		.byte	8
 3324 00be 95        		.byte	-107
 3325 00bf 03        		.byte	3
 3326 00c0 09        		.byte	9
 3327 00c1 00        		.byte	0
 3328 00c2 B2        		.byte	-78
 3329 00c3 02        		.byte	2
 3330 00c4 01        		.byte	1
 3331 00c5 C0        		.byte	-64
 3332               	.global	pdata
 3333               		.section .bss
 3336               	pdata:
 3337 0003 0000 00   		.zero	3
 3338               		.text
 3339               	.Letext0:
 3340               		.file 11 "/usr/lib/avr/include/stdint.h"
 3341               		.file 12 "usbdrv.h"
 3342               		.file 13 "/usr/lib/avr/include/avr/eeprom.h"
 3343               		.file 14 "/usr/lib/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/tmp/user/1000/ccxzkoBa.s:2      *ABS*:0000003e __SP_H__
/tmp/user/1000/ccxzkoBa.s:3      *ABS*:0000003d __SP_L__
/tmp/user/1000/ccxzkoBa.s:4      *ABS*:0000003f __SREG__
/tmp/user/1000/ccxzkoBa.s:5      *ABS*:00000000 __tmp_reg__
/tmp/user/1000/ccxzkoBa.s:6      *ABS*:00000001 __zero_reg__
/tmp/user/1000/ccxzkoBa.s:11     .text:00000000 setRelayState.part.2
/tmp/user/1000/ccxzkoBa.s:29     .text:00000004 usbFunctionRead
                             .bss:00000006 bytesRemaining
/tmp/user/1000/ccxzkoBa.s:3302   .bss:00000007 currentAddress
/tmp/user/1000/ccxzkoBa.s:3336   .bss:00000003 pdata
/tmp/user/1000/ccxzkoBa.s:129    .text:0000007e usbFunctionWrite
/tmp/user/1000/ccxzkoBa.s:237    .text:000000fc usbFunctionSetup
/tmp/user/1000/ccxzkoBa.s:276    .text:00000120 readPulseDuration
/tmp/user/1000/ccxzkoBa.s:3299   .eeprom:00000006 eeprom_pulse_duration
/tmp/user/1000/ccxzkoBa.s:295    .text:00000126 writePulseDuration
/tmp/user/1000/ccxzkoBa.s:316    .text:0000012e readPauseDuration
/tmp/user/1000/ccxzkoBa.s:3294   .eeprom:00000004 eeprom_pause_duration
/tmp/user/1000/ccxzkoBa.s:334    .text:00000134 writePauseDuration
/tmp/user/1000/ccxzkoBa.s:355    .text:0000013c readImpulseCount
/tmp/user/1000/ccxzkoBa.s:3289   .eeprom:00000002 eeprom_impulse_count
/tmp/user/1000/ccxzkoBa.s:373    .text:00000142 writeImpulseCount
/tmp/user/1000/ccxzkoBa.s:394    .text:0000014a readMode
/tmp/user/1000/ccxzkoBa.s:3284   .eeprom:00000000 eeprom_mode
/tmp/user/1000/ccxzkoBa.s:412    .text:00000150 writeMode
/tmp/user/1000/ccxzkoBa.s:436    .text:00000158 power
/tmp/user/1000/ccxzkoBa.s:523    .text:000001b4 strlen
/tmp/user/1000/ccxzkoBa.s:553    .text:000001c6 delay_ms
/tmp/user/1000/ccxzkoBa.s:594    .text:000001de WriteByte
/tmp/user/1000/ccxzkoBa.s:778    .text:0000027a WriteCmd
/tmp/user/1000/ccxzkoBa.s:796    .text:0000027e WriteData
/tmp/user/1000/ccxzkoBa.s:814    .text:00000282 LCDinit
/tmp/user/1000/ccxzkoBa.s:877    .text:000002b8 LCDFirstLine
/tmp/user/1000/ccxzkoBa.s:906    .text:000002ca LCDLastLine
/tmp/user/1000/ccxzkoBa.s:938    .text:000002de LCDClrScr
/tmp/user/1000/ccxzkoBa.s:967    .text:000002f0 LCDPrint
/tmp/user/1000/ccxzkoBa.s:1009   .text:00000306 LCDReturnHome
/tmp/user/1000/ccxzkoBa.s:1038   .text:00000318 LCDClearCurrLine
/tmp/user/1000/ccxzkoBa.s:1082   .text:00000330 LCDCursorShift
/tmp/user/1000/ccxzkoBa.s:1161   .text:00000362 printMenuEx
/tmp/user/1000/ccxzkoBa.s:3268   .bss:00000000 menu_duration
/tmp/user/1000/ccxzkoBa.s:1328   .text:00000404 printMenu
/tmp/user/1000/ccxzkoBa.s:1347   .text:0000040a ReadButtonFromPORTB
/tmp/user/1000/ccxzkoBa.s:1434   .text:0000046a ReadButtonFromPORTC
/tmp/user/1000/ccxzkoBa.s:1523   .text:000004ca ReadBtnTop
/tmp/user/1000/ccxzkoBa.s:1541   .text:000004d0 ReadBtnLeft
/tmp/user/1000/ccxzkoBa.s:1559   .text:000004d6 ReadBtnBottom
/tmp/user/1000/ccxzkoBa.s:1577   .text:000004dc ReadBtnRight
/tmp/user/1000/ccxzkoBa.s:1595   .text:000004e2 ReadBtnSelect
/tmp/user/1000/ccxzkoBa.s:1613   .text:000004e8 selectFromList
/tmp/user/1000/ccxzkoBa.s:1775   .text:00000574 msgBox
/tmp/user/1000/ccxzkoBa.s:1940   .text:00000606 getNumber
/tmp/user/1000/ccxzkoBa.s:2557   .text:0000087e setRelayState
/tmp/user/1000/ccxzkoBa.s:2608   .text:000008ae initIO
/tmp/user/1000/ccxzkoBa.s:2654   .text.startup:00000000 main
                            *COM*:00000002 def_pulse_duration
                            *COM*:00000002 def_pause_duration
                            *COM*:00000002 def_impulse_count
                            *COM*:00000002 def_mode
/tmp/user/1000/ccxzkoBa.s:3273   .bss:00000001 main_menu_index
/tmp/user/1000/ccxzkoBa.s:3250   .data:00000040 main_menu
/tmp/user/1000/ccxzkoBa.s:3278   .bss:00000002 menustate
/tmp/user/1000/ccxzkoBa.s:3235   .data:00000000 listOfModes
/tmp/user/1000/ccxzkoBa.s:3309   .data:000000b0 usbHidReportDescriptor

UNDEFINED SYMBOLS
__eerd_word_m8
__eewr_word_m8
__floatsisf
__divsf3
__fixsfsi
__itoa_ncheck
usbInit
usbPoll
round
__do_copy_data
__do_clear_bss
